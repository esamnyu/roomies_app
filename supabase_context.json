{
  "comment": "This JSON file contains the schema for the public tables, functions, and triggers in the Supabase database. It is intended to be used as context for an LLM.",
  "tables": [
    {
      "table_name": "chore_assignments",
      "comment": "Columns for the chore_assignments table.",
      "columns": [
        {
          "column_name": "id",
          "data_type": "uuid"
        },
        {
          "column_name": "household_chore_id",
          "data_type": "uuid"
        },
        {
          "column_name": "household_id",
          "data_type": "uuid"
        },
        {
          "column_name": "assigned_user_id",
          "data_type": "text"
        },
        {
          "column_name": "cycle_start_date",
          "data_type": "date"
        },
        {
          "column_name": "due_date",
          "data_type": "date"
        },
        {
          "column_name": "status",
          "data_type": "text"
        },
        {
          "column_name": "completed_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "completed_by_user_id",
          "data_type": "uuid"
        },
        {
          "column_name": "notes",
          "data_type": "text"
        },
        {
          "column_name": "created_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "updated_at",
          "data_type": "timestamp with time zone"
        }
      ]
    },
    {
      "table_name": "expense_idempotency",
      "comment": "Columns for the expense_idempotency table.",
      "columns": [
        {
          "column_name": "client_uuid",
          "data_type": "uuid"
        },
        {
          "column_name": "expense_id",
          "data_type": "uuid"
        },
        {
          "column_name": "created_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "request_hash",
          "data_type": "text"
        }
      ]
    },
    {
      "table_name": "expense_payments",
      "comment": "Columns for the expense_payments table.",
      "columns": [
        {
          "column_name": "id",
          "data_type": "uuid"
        },
        {
          "column_name": "expense_id",
          "data_type": "uuid"
        },
        {
          "column_name": "payer_id",
          "data_type": "uuid"
        },
        {
          "column_name": "amount",
          "data_type": "numeric"
        },
        {
          "column_name": "created_at",
          "data_type": "timestamp with time zone"
        }
      ]
    },
    {
      "table_name": "expense_split_adjustments",
      "comment": "Columns for the expense_split_adjustments table.",
      "columns": [
        {
          "column_name": "id",
          "data_type": "uuid"
        },
        {
          "column_name": "expense_split_id",
          "data_type": "uuid"
        },
        {
          "column_name": "adjustment_amount",
          "data_type": "numeric"
        },
        {
          "column_name": "reason",
          "data_type": "text"
        },
        {
          "column_name": "created_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "created_by",
          "data_type": "uuid"
        }
      ]
    },
    {
      "table_name": "expense_splits",
      "comment": "Columns for the expense_splits table.",
      "columns": [
        {
          "column_name": "id",
          "data_type": "uuid"
        },
        {
          "column_name": "expense_id",
          "data_type": "uuid"
        },
        {
          "column_name": "user_id",
          "data_type": "uuid"
        },
        {
          "column_name": "amount",
          "data_type": "numeric"
        },
        {
          "column_name": "settled",
          "data_type": "boolean"
        },
        {
          "column_name": "settled_at",
          "data_type": "timestamp with time zone"
        }
      ]
    },
    {
      "table_name": "expenses",
      "comment": "Columns for the expenses table.",
      "columns": [
        {
          "column_name": "id",
          "data_type": "uuid"
        },
        {
          "column_name": "household_id",
          "data_type": "uuid"
        },
        {
          "column_name": "description",
          "data_type": "text"
        },
        {
          "column_name": "amount",
          "data_type": "numeric"
        },
        {
          "column_name": "paid_by",
          "data_type": "uuid"
        },
        {
          "column_name": "date",
          "data_type": "date"
        },
        {
          "column_name": "created_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "updated_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "recurring_expense_id",
          "data_type": "uuid"
        },
        {
          "column_name": "version",
          "data_type": "integer"
        }
      ]
    },
    {
      "table_name": "household_chores",
      "comment": "Columns for the household_chores table.",
      "columns": [
        {
          "column_name": "id",
          "data_type": "uuid"
        },
        {
          "column_name": "household_id",
          "data_type": "uuid"
        },
        {
          "column_name": "name",
          "data_type": "text"
        },
        {
          "column_name": "description",
          "data_type": "text"
        },
        {
          "column_name": "is_core_chore",
          "data_type": "boolean"
        },
        {
          "column_name": "default_order",
          "data_type": "integer"
        },
        {
          "column_name": "is_active",
          "data_type": "boolean"
        },
        {
          "column_name": "created_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "updated_at",
          "data_type": "timestamp with time zone"
        }
      ]
    },
    {
      "table_name": "household_members",
      "comment": "Columns for the household_members table.",
      "columns": [
        {
          "column_name": "id",
          "data_type": "uuid"
        },
        {
          "column_name": "household_id",
          "data_type": "uuid"
        },
        {
          "column_name": "user_id",
          "data_type": "uuid"
        },
        {
          "column_name": "role",
          "data_type": "text"
        },
        {
          "column_name": "joined_at",
          "data_type": "timestamp with time zone"
        }
      ]
    },
    {
      "table_name": "households",
      "comment": "Columns for the households table.",
      "columns": [
        {
          "column_name": "id",
          "data_type": "uuid"
        },
        {
          "column_name": "name",
          "data_type": "text"
        },
        {
          "column_name": "created_by",
          "data_type": "uuid"
        },
        {
          "column_name": "created_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "updated_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "member_count",
          "data_type": "smallint"
        },
        {
          "column_name": "core_chores",
          "data_type": "ARRAY"
        },
        {
          "column_name": "chore_frequency",
          "data_type": "text"
        },
        {
          "column_name": "chore_framework",
          "data_type": "text"
        },
        {
          "column_name": "join_code",
          "data_type": "text"
        },
        {
          "column_name": "last_chore_rotation_date",
          "data_type": "date"
        },
        {
          "column_name": "next_chore_rotation_date",
          "data_type": "date"
        },
        {
          "column_name": "chore_current_assignee_index",
          "data_type": "integer"
        },
        {
          "column_name": "rules_document",
          "data_type": "text"
        },
        {
          "column_name": "rules_last_updated",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "rules",
          "data_type": "jsonb"
        }
      ]
    },
    {
      "table_name": "invitations",
      "comment": "Columns for the invitations table.",
      "columns": [
        {
          "column_name": "id",
          "data_type": "uuid"
        },
        {
          "column_name": "household_id",
          "data_type": "uuid"
        },
        {
          "column_name": "invited_by",
          "data_type": "uuid"
        },
        {
          "column_name": "email",
          "data_type": "text"
        },
        {
          "column_name": "status",
          "data_type": "text"
        },
        {
          "column_name": "created_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "expires_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "token",
          "data_type": "uuid"
        },
        {
          "column_name": "accepted_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "updated_at",
          "data_type": "timestamp with time zone"
        }
      ]
    },
    {
      "table_name": "ledger_balances",
      "comment": "Columns for the ledger_balances table.",
      "columns": [
        {
          "column_name": "id",
          "data_type": "uuid"
        },
        {
          "column_name": "household_id",
          "data_type": "uuid"
        },
        {
          "column_name": "user_id",
          "data_type": "uuid"
        },
        {
          "column_name": "balance",
          "data_type": "numeric"
        },
        {
          "column_name": "last_updated_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "created_at",
          "data_type": "timestamp with time zone"
        }
      ]
    },
    {
      "table_name": "messages",
      "comment": "Columns for the messages table.",
      "columns": [
        {
          "column_name": "id",
          "data_type": "uuid"
        },
        {
          "column_name": "household_id",
          "data_type": "uuid"
        },
        {
          "column_name": "user_id",
          "data_type": "uuid"
        },
        {
          "column_name": "content",
          "data_type": "text"
        },
        {
          "column_name": "edited",
          "data_type": "boolean"
        },
        {
          "column_name": "deleted",
          "data_type": "boolean"
        },
        {
          "column_name": "created_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "updated_at",
          "data_type": "timestamp with time zone"
        }
      ]
    },
    {
      "table_name": "notifications",
      "comment": "Columns for the notifications table.",
      "columns": [
        {
          "column_name": "id",
          "data_type": "uuid"
        },
        {
          "column_name": "user_id",
          "data_type": "uuid"
        },
        {
          "column_name": "household_id",
          "data_type": "uuid"
        },
        {
          "column_name": "type",
          "data_type": "character varying"
        },
        {
          "column_name": "title",
          "data_type": "text"
        },
        {
          "column_name": "message",
          "data_type": "text"
        },
        {
          "column_name": "data",
          "data_type": "jsonb"
        },
        {
          "column_name": "is_read",
          "data_type": "boolean"
        },
        {
          "column_name": "read_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "created_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "updated_at",
          "data_type": "timestamp with time zone"
        }
      ]
    },
    {
      "table_name": "profiles",
      "comment": "Columns for the profiles table.",
      "columns": [
        {
          "column_name": "id",
          "data_type": "uuid"
        },
        {
          "column_name": "name",
          "data_type": "text"
        },
        {
          "column_name": "avatar_url",
          "data_type": "text"
        },
        {
          "column_name": "created_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "updated_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "email",
          "data_type": "text"
        },
        {
          "column_name": "vacation_start_date",
          "data_type": "date"
        },
        {
          "column_name": "vacation_end_date",
          "data_type": "date"
        }
      ]
    },
    {
      "table_name": "recurring_expenses",
      "comment": "Columns for the recurring_expenses table.",
      "columns": [
        {
          "column_name": "id",
          "data_type": "uuid"
        },
        {
          "column_name": "household_id",
          "data_type": "uuid"
        },
        {
          "column_name": "description",
          "data_type": "text"
        },
        {
          "column_name": "amount",
          "data_type": "numeric"
        },
        {
          "column_name": "frequency",
          "data_type": "text"
        },
        {
          "column_name": "day_of_month",
          "data_type": "integer"
        },
        {
          "column_name": "day_of_week",
          "data_type": "integer"
        },
        {
          "column_name": "next_due_date",
          "data_type": "date"
        },
        {
          "column_name": "is_active",
          "data_type": "boolean"
        },
        {
          "column_name": "created_by",
          "data_type": "uuid"
        },
        {
          "column_name": "created_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "updated_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "splits",
          "data_type": "jsonb"
        },
        {
          "column_name": "last_processed_at",
          "data_type": "timestamp with time zone"
        }
      ]
    },
    {
      "table_name": "settlements",
      "comment": "Columns for the settlements table.",
      "columns": [
        {
          "column_name": "id",
          "data_type": "uuid"
        },
        {
          "column_name": "household_id",
          "data_type": "uuid"
        },
        {
          "column_name": "payer_id",
          "data_type": "uuid"
        },
        {
          "column_name": "payee_id",
          "data_type": "uuid"
        },
        {
          "column_name": "amount",
          "data_type": "numeric"
        },
        {
          "column_name": "description",
          "data_type": "text"
        },
        {
          "column_name": "created_at",
          "data_type": "timestamp with time zone"
        }
      ]
    },
    {
      "table_name": "tasks",
      "comment": "Columns for the tasks table.",
      "columns": [
        {
          "column_name": "id",
          "data_type": "uuid"
        },
        {
          "column_name": "household_id",
          "data_type": "uuid"
        },
        {
          "column_name": "title",
          "data_type": "text"
        },
        {
          "column_name": "assigned_to",
          "data_type": "uuid"
        },
        {
          "column_name": "completed",
          "data_type": "boolean"
        },
        {
          "column_name": "completed_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "created_at",
          "data_type": "timestamp with time zone"
        },
        {
          "column_name": "updated_at",
          "data_type": "timestamp with time zone"
        }
      ]
    }
  ],
  "functions": [
    {
      "function_name": "handle_invitations_updated_at",
      "comment": "Definition for the handle_invitations_updated_at function.",
      "definition": "CREATE OR REPLACE FUNCTION public.handle_invitations_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_household_full_data",
      "comment": "Definition for the get_household_full_data function.",
      "definition": "CREATE OR REPLACE FUNCTION public.get_household_full_data(p_household_id uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  result json;\nBEGIN\n  SELECT json_build_object(\n    'household', row_to_json(h.*),\n    'members', COALESCE(json_agg(DISTINCT jsonb_build_object(\n      'id', hm.id,\n      'user_id', hm.user_id,\n      'role', hm.role,\n      'joined_at', hm.joined_at,\n      'profile', row_to_json(p.*)\n    )) FILTER (WHERE hm.id IS NOT NULL), '[]'::json),\n    'expenses', COALESCE(json_agg(DISTINCT jsonb_build_object(\n      'id', e.id,\n      'description', e.description,\n      'amount', e.amount,\n      'paid_by', e.paid_by,\n      'date', e.date,\n      'created_at', e.created_at,\n      'payer_profile', row_to_json(ep.*),\n      'splits', (\n        SELECT json_agg(jsonb_build_object(\n          'id', es.id,\n          'user_id', es.user_id,\n          'amount', es.amount,\n          'settled', es.settled,\n          'profile', row_to_json(esp.*)\n        ))\n        FROM expense_splits es\n        LEFT JOIN profiles esp ON esp.id = es.user_id\n        WHERE es.expense_id = e.id\n      )\n    )) FILTER (WHERE e.id IS NOT NULL), '[]'::json),\n    'recurring_expenses', COALESCE(json_agg(DISTINCT row_to_json(re.*)) \n      FILTER (WHERE re.id IS NOT NULL), '[]'::json),\n    'balances', (\n      SELECT json_agg(b.*) FROM calculate_household_balances(p_household_id) b\n    ),\n    'recent_settlements', COALESCE(json_agg(DISTINCT jsonb_build_object(\n      'id', s.id,\n      'payer_id', s.payer_id,\n      'payee_id', s.payee_id,\n      'amount', s.amount,\n      'description', s.description,\n      'created_at', s.created_at,\n      'payer_profile', row_to_json(sp1.*),\n      'payee_profile', row_to_json(sp2.*)\n    )) FILTER (WHERE s.id IS NOT NULL), '[]'::json),\n    'active_chores', COALESCE(json_agg(DISTINCT jsonb_build_object(\n      'id', ca.id,\n      'due_date', ca.due_date,\n      'status', ca.status,\n      'chore_name', hc.name,\n      'assigned_to', row_to_json(cap.*)\n    )) FILTER (WHERE ca.id IS NOT NULL AND ca.status = 'pending'), '[]'::json)\n  ) INTO result\n  FROM households h\n  LEFT JOIN household_members hm ON h.id = hm.household_id\n  LEFT JOIN profiles p ON p.id = hm.user_id\n  LEFT JOIN expenses e ON e.household_id = h.id \n    AND e.created_at > NOW() - INTERVAL '30 days'\n  LEFT JOIN profiles ep ON ep.id = e.paid_by\n  LEFT JOIN recurring_expenses re ON re.household_id = h.id \n    AND re.is_active = true\n  LEFT JOIN settlements s ON s.household_id = h.id \n    AND s.created_at > NOW() - INTERVAL '30 days'\n  LEFT JOIN profiles sp1 ON sp1.id = s.payer_id\n  LEFT JOIN profiles sp2 ON sp2.id = s.payee_id\n  LEFT JOIN chore_assignments ca ON ca.household_id = h.id\n  LEFT JOIN household_chores hc ON hc.id = ca.household_chore_id\n  LEFT JOIN profiles cap ON cap.id = ca.assigned_user_id\n  WHERE h.id = p_household_id\n  GROUP BY h.id;\n  \n  RETURN result;\nEND;\n$function$\n"
    },
    {
      "function_name": "expire_old_invitations",
      "comment": "Definition for the expire_old_invitations function.",
      "definition": "CREATE OR REPLACE FUNCTION public.expire_old_invitations()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    UPDATE invitations\n    SET status = 'expired'\n    WHERE status = 'pending'\n    AND expires_at < NOW();\nEND;\n$function$\n"
    },
    {
      "function_name": "create_household_notification",
      "comment": "Definition for the create_household_notification function.",
      "definition": "CREATE OR REPLACE FUNCTION public.create_household_notification(p_household_id uuid, p_type character varying, p_title text, p_message text, p_data jsonb DEFAULT '{}'::jsonb, p_exclude_user_id uuid DEFAULT NULL::uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    INSERT INTO notifications (user_id, household_id, type, title, message, data)\n    SELECT \n        hm.user_id,\n        p_household_id,\n        p_type,\n        p_title,\n        p_message,\n        p_data\n    FROM household_members hm\n    WHERE hm.household_id = p_household_id\n    AND (p_exclude_user_id IS NULL OR hm.user_id != p_exclude_user_id);\nEND;\n$function$\n"
    },
    {
      "function_name": "mark_notifications_read",
      "comment": "Definition for the mark_notifications_read function.",
      "definition": "CREATE OR REPLACE FUNCTION public.mark_notifications_read(p_notification_ids uuid[])\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    UPDATE notifications\n    SET \n        is_read = TRUE,\n        read_at = NOW(),\n        updated_at = NOW()\n    WHERE id = ANY(p_notification_ids)\n    AND user_id = auth.uid();\nEND;\n$function$\n"
    },
    {
      "function_name": "notify_task_assigned",
      "comment": "Definition for the notify_task_assigned function.",
      "definition": "CREATE OR REPLACE FUNCTION public.notify_task_assigned()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_assigner_name TEXT;\nBEGIN\n    -- Only notify if task is assigned to someone\n    IF NEW.assigned_to IS NOT NULL AND (OLD.assigned_to IS NULL OR OLD.assigned_to != NEW.assigned_to) THEN\n        -- Get current user's name (task creator/updater)\n        SELECT name INTO v_assigner_name\n        FROM profiles\n        WHERE id = auth.uid();\n        \n        -- Create notification for assigned user\n        INSERT INTO notifications (user_id, household_id, type, title, message, data)\n        VALUES (\n            NEW.assigned_to,\n            NEW.household_id,\n            'task_assigned',\n            'New Task Assigned',\n            format('You have been assigned: %s', NEW.title),\n            jsonb_build_object(\n                'task_id', NEW.id,\n                'title', NEW.title,\n                'assigned_by', auth.uid()\n            )\n        );\n    END IF;\n    \n    RETURN NEW;\nEND;\n$function$\n"
    },
    {
      "function_name": "update_ledger_balance",
      "comment": "Definition for the update_ledger_balance function.",
      "definition": "CREATE OR REPLACE FUNCTION public.update_ledger_balance(p_household_id uuid, p_user_id uuid, p_delta numeric)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    INSERT INTO public.ledger_balances (household_id, user_id, balance)\n    VALUES (p_household_id, p_user_id, p_delta)\n    ON CONFLICT (household_id, user_id)\n    DO UPDATE SET \n        balance = ledger_balances.balance + p_delta,\n        last_updated_at = NOW();\nEND;\n$function$\n"
    },
    {
      "function_name": "notify_settlement_created",
      "comment": "Definition for the notify_settlement_created function.",
      "definition": "CREATE OR REPLACE FUNCTION public.notify_settlement_created()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_payer_name TEXT;\n    v_payee_name TEXT;\nBEGIN\n    -- Get payer and payee names\n    SELECT name INTO v_payer_name\n    FROM profiles\n    WHERE id = NEW.payer_id;\n    \n    SELECT name INTO v_payee_name\n    FROM profiles\n    WHERE id = NEW.payee_id;\n    \n    -- Notify the payee\n    INSERT INTO notifications (user_id, household_id, type, title, message, data)\n    VALUES (\n        NEW.payee_id,\n        NEW.household_id,\n        'settlement_recorded',\n        'Payment Received',\n        format('%s paid you $%s', v_payer_name, NEW.amount::NUMERIC(10,2)),\n        jsonb_build_object(\n            'settlement_id', NEW.id,\n            'amount', NEW.amount,\n            'payer_id', NEW.payer_id\n        )\n    );\n    \n    -- Notify other household members\n    PERFORM create_household_notification(\n        NEW.household_id,\n        'settlement_recorded',\n        'Settlement Recorded',\n        format('%s paid %s $%s', v_payer_name, v_payee_name, NEW.amount::NUMERIC(10,2)),\n        jsonb_build_object(\n            'settlement_id', NEW.id,\n            'amount', NEW.amount,\n            'payer_id', NEW.payer_id,\n            'payee_id', NEW.payee_id\n        ),\n        NEW.payer_id -- Exclude both payer and payee from general notification\n    );\n    \n    -- Remove the payee from the general notification\n    DELETE FROM notifications \n    WHERE household_id = NEW.household_id \n    AND user_id = NEW.payee_id \n    AND data->>'settlement_id' = NEW.id::TEXT\n    AND type = 'settlement_recorded'\n    AND title = 'Settlement Recorded';\n    \n    RETURN NEW;\nEND;\n$function$\n"
    },
    {
      "function_name": "create_payment_reminders",
      "comment": "Definition for the create_payment_reminders function.",
      "definition": "CREATE OR REPLACE FUNCTION public.create_payment_reminders()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_balance RECORD;\n    v_creditor_name TEXT;\n    v_last_reminder TIMESTAMPTZ;\nBEGIN\n    -- Get all negative balances (debts)\n    FOR v_balance IN\n        WITH balance_calculation AS (\n            SELECT \n                hm.household_id,\n                hm.user_id,\n                COALESCE(\n                    SUM(CASE \n                        WHEN e.paid_by = hm.user_id THEN e.amount \n                        ELSE 0 \n                    END) - \n                    SUM(CASE \n                        WHEN es.user_id = hm.user_id AND NOT es.settled THEN es.amount \n                        ELSE 0 \n                    END) -\n                    SUM(CASE \n                        WHEN s.payer_id = hm.user_id THEN s.amount \n                        ELSE 0 \n                    END) +\n                    SUM(CASE \n                        WHEN s.payee_id = hm.user_id THEN s.amount \n                        ELSE 0 \n                    END), \n                    0\n                ) as balance\n            FROM household_members hm\n            LEFT JOIN expenses e ON e.household_id = hm.household_id\n            LEFT JOIN expense_splits es ON es.expense_id = e.id\n            LEFT JOIN settlements s ON s.household_id = hm.household_id\n            GROUP BY hm.household_id, hm.user_id\n            HAVING COALESCE(\n                SUM(CASE \n                    WHEN e.paid_by = hm.user_id THEN e.amount \n                    ELSE 0 \n                END) - \n                SUM(CASE \n                    WHEN es.user_id = hm.user_id AND NOT es.settled THEN es.amount \n                    ELSE 0 \n                END) -\n                SUM(CASE \n                    WHEN s.payer_id = hm.user_id THEN s.amount \n                    ELSE 0 \n                END) +\n                SUM(CASE \n                    WHEN s.payee_id = hm.user_id THEN s.amount \n                    ELSE 0 \n                END), \n                0\n            ) < -5 -- Only remind for debts over $5\n        )\n        SELECT * FROM balance_calculation\n    LOOP\n        -- Check if we sent a reminder in the last 3 days\n        SELECT MAX(created_at) INTO v_last_reminder\n        FROM notifications\n        WHERE user_id = v_balance.user_id\n        AND type = 'payment_reminder'\n        AND household_id = v_balance.household_id;\n        \n        IF v_last_reminder IS NULL OR v_last_reminder < NOW() - INTERVAL '3 days' THEN\n            INSERT INTO notifications (user_id, household_id, type, title, message, data)\n            VALUES (\n                v_balance.user_id,\n                v_balance.household_id,\n                'payment_reminder',\n                'Payment Reminder',\n                format('You have an outstanding balance of $%s', ABS(v_balance.balance)::NUMERIC(10,2)),\n                jsonb_build_object(\n                    'balance', v_balance.balance\n                )\n            );\n        END IF;\n    END LOOP;\nEND;\n$function$\n"
    },
    {
      "function_name": "notify_recurring_expense_processed",
      "comment": "Definition for the notify_recurring_expense_processed function.",
      "definition": "CREATE OR REPLACE FUNCTION public.notify_recurring_expense_processed()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if this expense was created from a recurring expense\n    IF NEW.description LIKE '%(Recurring)%' THEN\n        PERFORM create_household_notification(\n            NEW.household_id,\n            'recurring_expense_added',\n            'Recurring Expense Added',\n            format('Recurring expense \"%s\" of $%s has been added', \n                NEW.description, \n                NEW.amount::NUMERIC(10,2)\n            ),\n            jsonb_build_object(\n                'expense_id', NEW.id,\n                'amount', NEW.amount,\n                'description', NEW.description\n            )\n        );\n    END IF;\n    \n    RETURN NEW;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_unread_notification_count",
      "comment": "Definition for the get_unread_notification_count function.",
      "definition": "CREATE OR REPLACE FUNCTION public.get_unread_notification_count(p_user_id uuid)\n RETURNS integer\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_count INTEGER;\nBEGIN\n    SELECT COUNT(*) INTO v_count\n    FROM notifications\n    WHERE user_id = p_user_id\n    AND is_read = FALSE;\n    \n    RETURN v_count;\nEND;\n$function$\n"
    },
    {
      "function_name": "notify_expense_created",
      "comment": "Definition for the notify_expense_created function.",
      "definition": "CREATE OR REPLACE FUNCTION public.notify_expense_created()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_payer_name TEXT;\r\n    v_split RECORD;\r\nBEGIN\r\n    -- Get the name of the person who paid\r\n    SELECT name INTO v_payer_name\r\n    FROM profiles\r\n    WHERE id = NEW.paid_by;\r\n\r\n    -- Loop through each split for the new expense\r\n    FOR v_split IN\r\n        SELECT user_id, amount\r\n        FROM expense_splits\r\n        WHERE expense_id = NEW.id\r\n    LOOP\r\n        -- Don't send a notification to the person who paid\r\n        IF v_split.user_id != NEW.paid_by THEN\r\n            -- Create a personalized notification for each user\r\n            INSERT INTO notifications (user_id, household_id, type, title, message, data)\r\n            VALUES (\r\n                v_split.user_id,\r\n                NEW.household_id,\r\n                'expense_added',\r\n                'New Expense Added',\r\n                format('%s paid $%s for %s. Your share: $%s',\r\n                       v_payer_name,\r\n                       NEW.amount::NUMERIC(10,2),\r\n                       NEW.description,\r\n                       v_split.amount::NUMERIC(10,2)\r\n                ),\r\n                jsonb_build_object(\r\n                    'expense_id', NEW.id,\r\n                    'amount', v_split.amount,\r\n                    'description', NEW.description,\r\n                    'paid_by', NEW.paid_by\r\n                )\r\n            );\r\n        END IF;\r\n    END LOOP;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
    },
    {
      "function_name": "remove_member_from_household",
      "comment": "Definition for the remove_member_from_household function.",
      "definition": "CREATE OR REPLACE FUNCTION public.remove_member_from_household(member_id_to_remove uuid, household_id_to_check uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  admin_count integer;\nBEGIN\n  -- Check how many admins are left\n  SELECT count(*) INTO admin_count\n  FROM household_members\n  WHERE household_id = household_id_to_check AND role = 'admin';\n\n  -- Prevent removing the last admin\n  IF admin_count <= 1 AND (SELECT role FROM household_members WHERE id = member_id_to_remove) = 'admin' THEN\n    RAISE EXCEPTION 'Cannot remove the last admin from the household.';\n  END IF;\n\n  -- Proceed with deletion\n  DELETE FROM household_members WHERE id = member_id_to_remove;\nEND;\n$function$\n"
    },
    {
      "function_name": "update_expense",
      "comment": "Definition for the update_expense function.",
      "definition": "CREATE OR REPLACE FUNCTION public.update_expense(p_expense_id uuid, p_description text, p_amount numeric, p_payer_id uuid, p_splits jsonb, p_paid_at timestamp with time zone DEFAULT NULL::timestamp with time zone, p_adjustment_reason text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_old_expense RECORD;\n    v_old_split RECORD;\n    v_new_amount numeric;\n    v_adjustment_reason text;\nBEGIN\n    -- Get the old expense data\n    SELECT * INTO v_old_expense FROM public.expenses WHERE id = p_expense_id;\n    \n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Expense not found';\n    END IF;\n    \n    -- Set adjustment reason\n    v_adjustment_reason := COALESCE(p_adjustment_reason, 'Expense updated');\n    \n    -- Begin transaction\n    BEGIN\n        -- Update the expense\n        UPDATE public.expenses\n        SET \n            description = p_description,\n            amount = p_amount,\n            payer_id = p_payer_id,\n            paid_at = p_paid_at,\n            updated_at = NOW()\n        WHERE id = p_expense_id;\n        \n        -- Handle splits\n        FOR v_old_split IN \n            SELECT * FROM public.expense_splits \n            WHERE expense_id = p_expense_id\n        LOOP\n            -- Check if this user still has a split\n            SELECT (s->>'amount')::numeric INTO v_new_amount\n            FROM jsonb_array_elements(p_splits) s\n            WHERE (s->>'user_id')::uuid = v_old_split.user_id;\n            \n            IF FOUND AND v_new_amount != v_old_split.amount THEN\n                -- Split amount changed\n                IF v_old_split.settled THEN\n                    -- Create adjustment for settled split\n                    INSERT INTO public.expense_split_adjustments (\n                        expense_split_id,\n                        adjustment_amount,\n                        reason,\n                        created_at,\n                        created_by\n                    )\n                    VALUES (\n                        v_old_split.id,\n                        v_new_amount - v_old_split.amount,\n                        v_adjustment_reason,\n                        NOW(),\n                        auth.uid()\n                    );\n                    \n                    -- Keep original split unchanged for audit trail\n                ELSE\n                    -- Update unsettled split directly\n                    UPDATE public.expense_splits\n                    SET \n                        amount = v_new_amount,\n                        updated_at = NOW()\n                    WHERE id = v_old_split.id;\n                END IF;\n            ELSIF NOT FOUND THEN\n                -- User removed from split\n                IF v_old_split.settled THEN\n                    -- Create adjustment to zero out settled split\n                    INSERT INTO public.expense_split_adjustments (\n                        expense_split_id,\n                        adjustment_amount,\n                        reason,\n                        created_at,\n                        created_by\n                    )\n                    VALUES (\n                        v_old_split.id,\n                        -v_old_split.amount,\n                        v_adjustment_reason,\n                        NOW(),\n                        auth.uid()\n                    );\n                ELSE\n                    -- Delete unsettled split\n                    DELETE FROM public.expense_splits WHERE id = v_old_split.id;\n                END IF;\n            END IF;\n        END LOOP;\n        \n        -- Add new splits\n        INSERT INTO public.expense_splits (expense_id, user_id, amount, settled)\n        SELECT \n            p_expense_id,\n            (s->>'user_id')::uuid,\n            (s->>'amount')::numeric,\n            false\n        FROM jsonb_array_elements(p_splits) s\n        WHERE NOT EXISTS (\n            SELECT 1 FROM public.expense_splits es \n            WHERE es.expense_id = p_expense_id \n            AND es.user_id = (s->>'user_id')::uuid\n        );\n        \n        -- Return success\n        RETURN jsonb_build_object(\n            'success', true,\n            'expense_id', p_expense_id\n        );\n        \n    EXCEPTION\n        WHEN OTHERS THEN\n            RAISE EXCEPTION 'Failed to update expense: %', SQLERRM;\n    END;\nEND;\n$function$\n"
    },
    {
      "function_name": "handle_user_deletion",
      "comment": "Definition for the handle_user_deletion function.",
      "definition": "CREATE OR REPLACE FUNCTION public.handle_user_deletion()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$BEGIN\n    -- Log the deletion attempt\n    RAISE NOTICE 'Processing deletion for user: %', OLD.id;\n\n    -- Resilience Check: Prevent deleting the last admin of a household\n    IF EXISTS (\n        SELECT 1\n        FROM public.household_members hm\n        WHERE hm.user_id = OLD.id AND hm.role = 'admin'\n          AND (SELECT COUNT(*) FROM public.household_members WHERE household_id = hm.household_id AND role = 'admin') <= 1\n    ) THEN\n        RAISE EXCEPTION 'Cannot delete the last admin of a household. Please assign another admin before deleting this user.';\n    END IF;\n\n    -- Delete all related data in the correct order\n    \n    -- 1. Delete notifications\n    DELETE FROM public.notifications WHERE user_id = OLD.id;\n    \n    -- 2. Delete expense splits (must come before expenses)\n    DELETE FROM public.expense_splits WHERE user_id = OLD.id;\n    \n    -- 3. Delete settlements where user is involved\n    DELETE FROM public.settlements WHERE payer_id = OLD.id OR payee_id = OLD.id;\n    \n    -- 4. Delete expenses paid by user\n    DELETE FROM public.expenses WHERE paid_by = OLD.id;\n    \n    -- 5. Remove user from households\n    DELETE FROM public.household_members WHERE user_id = OLD.id;\n    \n    -- 6. Delete recurring expenses created by user\n    DELETE FROM public.recurring_expenses WHERE created_by = OLD.id;\n    \n    -- 7. Update tasks - set assigned_to to NULL\n    UPDATE public.tasks SET assigned_to = NULL WHERE assigned_to = OLD.id;\n    \n    -- 8. Update invitations - set invited_by to NULL\n    UPDATE public.invitations SET invited_by = NULL WHERE invited_by = OLD.id;\n    \n    -- 9. Update households - set created_by to NULL\n    UPDATE public.households SET created_by = NULL WHERE created_by = OLD.id;\n    \n    -- 10. Delete user profile\n    DELETE FROM public.profiles WHERE id = OLD.id;\n    \n    RAISE NOTICE 'Successfully cleaned up data for user: %', OLD.id;\n    \n    RETURN OLD;\nEXCEPTION\n    WHEN OTHERS THEN\n        -- Re-raise the exception to abort the transaction and prevent orphaned data\n        RAISE EXCEPTION 'Error during user deletion cleanup: %', SQLERRM;\nEND;$function$\n"
    },
    {
      "function_name": "notify_message_sent",
      "comment": "Definition for the notify_message_sent function.",
      "definition": "CREATE OR REPLACE FUNCTION public.notify_message_sent()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Get sender's name\n  DECLARE\n    sender_name TEXT;\n    household_name TEXT;\n  BEGIN\n    SELECT p.name INTO sender_name\n    FROM profiles p\n    WHERE p.id = NEW.user_id;\n    \n    SELECT h.name INTO household_name\n    FROM households h\n    WHERE h.id = NEW.household_id;\n\n    -- Create notifications for all other household members\n    INSERT INTO notifications (\n      user_id,\n      household_id,\n      type,\n      title,\n      message,\n      data,\n      is_read\n    )\n    SELECT \n      hm.user_id,\n      NEW.household_id,\n      'message_sent',\n      'New Message',\n      sender_name || ' sent a message in ' || household_name,\n      jsonb_build_object(\n        'message_id', NEW.id,\n        'sender_id', NEW.user_id,\n        'preview', LEFT(NEW.content, 50)\n      ),\n      FALSE\n    FROM household_members hm\n    WHERE hm.household_id = NEW.household_id\n      AND hm.user_id != NEW.user_id;\n    \n    RETURN NEW;\n  END;\nEND;\n$function$\n"
    },
    {
      "function_name": "update_expense_with_adjustments",
      "comment": "Definition for the update_expense_with_adjustments function.",
      "definition": "CREATE OR REPLACE FUNCTION public.update_expense_with_adjustments(p_expense_id uuid, p_description text, p_amount numeric, p_payments jsonb, p_splits jsonb, p_date date, p_expected_version integer DEFAULT NULL::integer)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_expense record;\r\n    v_old_payment record;\r\n    v_old_split record;\r\n    v_new_payment record;\r\n    v_new_split record;\r\n    v_adjustment_reason text;\r\n    v_total_paid numeric := 0;\r\n    v_total_split numeric := 0;\r\n    v_new_amount numeric;\r\n    v_current_user_id uuid;\r\nBEGIN\r\n    -- Get current user ID\r\n    SELECT auth.uid() INTO v_current_user_id;\r\n    \r\n    -- Lock and get current expense with version check\r\n    SELECT * INTO v_expense\r\n    FROM public.expenses\r\n    WHERE id = p_expense_id\r\n    FOR UPDATE;\r\n    \r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Expense not found';\r\n    END IF;\r\n    \r\n    -- Optimistic concurrency check\r\n    IF p_expected_version IS NOT NULL AND v_expense.version != p_expected_version THEN\r\n        RAISE EXCEPTION 'Expense has been modified by another user';\r\n    END IF;\r\n    \r\n    -- Validate new amounts\r\n    SELECT SUM((p->>'amount')::numeric) INTO v_total_paid\r\n    FROM jsonb_array_elements(p_payments) p;\r\n    \r\n    SELECT SUM((s->>'amount')::numeric) INTO v_total_split\r\n    FROM jsonb_array_elements(p_splits) s;\r\n    \r\n    IF abs(v_total_paid - p_amount) > 0.01 OR abs(v_total_split - p_amount) > 0.01 THEN\r\n        RAISE EXCEPTION 'Payment/split amounts do not match expense amount';\r\n    END IF;\r\n    \r\n    -- Start adjustment process\r\n    v_adjustment_reason := format('Expense modified on %s', CURRENT_DATE);\r\n    \r\n    -- Process payment changes\r\n    FOR v_old_payment IN \r\n        SELECT * FROM public.expense_payments\r\n        WHERE expense_id = p_expense_id\r\n    LOOP\r\n        BEGIN\r\n            -- Find corresponding new payment\r\n            SELECT * INTO v_new_payment FROM jsonb_to_recordset(p_payments) \r\n            AS x(payer_id uuid, amount numeric)\r\n            WHERE payer_id = v_old_payment.payer_id;\r\n            \r\n            IF FOUND AND v_new_payment.amount != v_old_payment.amount THEN\r\n                -- Update payment amount\r\n                UPDATE public.expense_payments\r\n                SET amount = v_new_payment.amount\r\n                WHERE id = v_old_payment.id;\r\n                \r\n                -- Update ledger for payment change\r\n                PERFORM update_ledger_balance(\r\n                    v_expense.household_id,\r\n                    v_old_payment.payer_id,\r\n                    v_new_payment.amount - v_old_payment.amount\r\n                );\r\n            ELSIF NOT FOUND THEN\r\n                -- Remove old payer\r\n                DELETE FROM public.expense_payments WHERE id = v_old_payment.id;\r\n                \r\n                -- Update ledger\r\n                PERFORM update_ledger_balance(\r\n                    v_expense.household_id,\r\n                    v_old_payment.payer_id,\r\n                    -v_old_payment.amount\r\n                );\r\n            END IF;\r\n        END;\r\n    END LOOP;\r\n    \r\n    -- Add new payers\r\n    FOR v_new_payment IN\r\n        SELECT * FROM jsonb_to_recordset(p_payments) \r\n        AS x(payer_id uuid, amount numeric)\r\n    LOOP\r\n        -- Check if payment exists\r\n        IF NOT EXISTS (\r\n            SELECT 1 FROM public.expense_payments\r\n            WHERE expense_id = p_expense_id\r\n            AND payer_id = v_new_payment.payer_id\r\n        ) THEN\r\n            -- New payer\r\n            INSERT INTO public.expense_payments (\r\n                expense_id, \r\n                payer_id, \r\n                amount\r\n            )\r\n            VALUES (\r\n                p_expense_id,\r\n                v_new_payment.payer_id,\r\n                v_new_payment.amount\r\n            );\r\n            \r\n            -- Update ledger\r\n            PERFORM update_ledger_balance(\r\n                v_expense.household_id,\r\n                v_new_payment.payer_id,\r\n                v_new_payment.amount\r\n            );\r\n        END IF;\r\n    END LOOP;\r\n    \r\n    -- Process split changes\r\n    FOR v_old_split IN \r\n        SELECT * FROM public.expense_splits\r\n        WHERE expense_id = p_expense_id\r\n    LOOP\r\n        BEGIN\r\n            -- Find corresponding new split\r\n            SELECT (s->>'amount')::numeric INTO v_new_amount\r\n            FROM jsonb_array_elements(p_splits) s\r\n            WHERE (s->>'user_id')::uuid = v_old_split.user_id;\r\n            \r\n            IF FOUND AND v_new_amount != v_old_split.amount THEN\r\n                -- Split amount changed\r\n                IF v_old_split.settled THEN\r\n                    -- Create adjustment for settled split\r\n                    -- FIXED: Removed original_amount column\r\n                    INSERT INTO public.expense_split_adjustments (\r\n                        expense_split_id,\r\n                        adjustment_amount,\r\n                        reason,\r\n                        created_at,\r\n                        created_by\r\n                    )\r\n                    VALUES (\r\n                        v_old_split.id,\r\n                        v_new_amount - v_old_split.amount,\r\n                        v_adjustment_reason,\r\n                        NOW(),\r\n                        v_current_user_id\r\n                    );\r\n                    \r\n                    -- Keep original split unchanged for audit trail\r\n                ELSE\r\n                    -- Update unsettled split directly\r\n                    UPDATE public.expense_splits\r\n                    SET amount = v_new_amount\r\n                    WHERE id = v_old_split.id;\r\n                END IF;\r\n                \r\n                -- FIXED: Correct ledger balance calculation\r\n                -- Negative of the increase in what they owe\r\n                PERFORM update_ledger_balance(\r\n                    v_expense.household_id,\r\n                    v_old_split.user_id,\r\n                    -(v_new_amount - v_old_split.amount)\r\n                );\r\n            ELSIF NOT FOUND THEN\r\n                -- Remove old split user\r\n                DELETE FROM public.expense_splits WHERE id = v_old_split.id;\r\n                \r\n                -- Update ledger (user no longer owes this amount)\r\n                PERFORM update_ledger_balance(\r\n                    v_expense.household_id,\r\n                    v_old_split.user_id,\r\n                    v_old_split.amount\r\n                );\r\n            END IF;\r\n        END;\r\n    END LOOP;\r\n    \r\n    -- Add new split users\r\n    FOR v_new_split IN\r\n        SELECT * FROM jsonb_to_recordset(p_splits) \r\n        AS x(user_id uuid, amount numeric)\r\n    LOOP\r\n        -- Check if split exists\r\n        IF NOT EXISTS (\r\n            SELECT 1 FROM public.expense_splits\r\n            WHERE expense_id = p_expense_id\r\n            AND user_id = v_new_split.user_id\r\n        ) THEN\r\n            -- New split user\r\n            INSERT INTO public.expense_splits (\r\n                expense_id, \r\n                user_id, \r\n                amount, \r\n                settled\r\n            )\r\n            VALUES (\r\n                p_expense_id,\r\n                v_new_split.user_id,\r\n                v_new_split.amount,\r\n                false\r\n            );\r\n            \r\n            -- Update ledger\r\n            PERFORM update_ledger_balance(\r\n                v_expense.household_id,\r\n                v_new_split.user_id,\r\n                -v_new_split.amount\r\n            );\r\n        END IF;\r\n    END LOOP;\r\n    \r\n    -- Update expense details\r\n    UPDATE public.expenses\r\n    SET \r\n        description = p_description,\r\n        amount = p_amount,\r\n        paid_by = (p_payments->0->>'payer_id')::uuid,\r\n        date = p_date,\r\n        version = version + 1,\r\n        updated_at = NOW()\r\n    WHERE id = p_expense_id;\r\n    \r\n    RETURN jsonb_build_object(\r\n        'success', true,\r\n        'expense_id', p_expense_id,\r\n        'version', v_expense.version + 1,\r\n        'message', 'Expense updated successfully with adjustments tracked'\r\n    );\r\n    \r\nEXCEPTION WHEN OTHERS THEN\r\n    RAISE EXCEPTION 'Failed to update expense: %', SQLERRM;\r\nEND;\r\n$function$\n"
    },
    {
      "function_name": "swap_chore_assignments",
      "comment": "Definition for the swap_chore_assignments function.",
      "definition": "CREATE OR REPLACE FUNCTION public.swap_chore_assignments(p_assignment1_id uuid, p_assignment2_id uuid, p_reason text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_assignment1 RECORD;\n    v_assignment2 RECORD;\n    v_user_id uuid;\n    v_temp_user_id text;\nBEGIN\n    -- Get current user\n    v_user_id := auth.uid();\n    \n    -- Get both assignments\n    SELECT * INTO v_assignment1 FROM chore_assignments WHERE id = p_assignment1_id;\n    SELECT * INTO v_assignment2 FROM chore_assignments WHERE id = p_assignment2_id;\n    \n    -- Validate assignments exist\n    IF v_assignment1.id IS NULL OR v_assignment2.id IS NULL THEN\n        RAISE EXCEPTION 'One or both assignments not found';\n    END IF;\n    \n    -- Validate both are from same household\n    IF v_assignment1.household_id != v_assignment2.household_id THEN\n        RAISE EXCEPTION 'Assignments must be from the same household';\n    END IF;\n    \n    -- Validate both are pending\n    IF v_assignment1.status != 'pending' OR v_assignment2.status != 'pending' THEN\n        RAISE EXCEPTION 'Can only swap pending assignments';\n    END IF;\n    \n    -- Check user permission (must be one of the assigned users or admin)\n    IF v_user_id::text NOT IN (v_assignment1.assigned_user_id, v_assignment2.assigned_user_id) THEN\n        -- Check if admin\n        SELECT COUNT(*) INTO v_assignment1\n        FROM household_members\n        WHERE household_id = v_assignment1.household_id\n        AND user_id = v_user_id\n        AND role = 'admin';\n        \n        IF v_assignment1.count = 0 THEN\n            RAISE EXCEPTION 'Only assigned users or admin can swap chores';\n        END IF;\n    END IF;\n    \n    -- Perform the swap\n    v_temp_user_id := v_assignment1.assigned_user_id;\n    \n    UPDATE chore_assignments\n    SET \n        assigned_user_id = v_assignment2.assigned_user_id,\n        notes = COALESCE(notes || E'\\n', '') || \n                format('Swapped with user on %s%s', \n                       NOW()::date::text,\n                       CASE WHEN p_reason IS NOT NULL THEN ' - ' || p_reason ELSE '' END),\n        updated_at = NOW()\n    WHERE id = p_assignment1_id;\n    \n    UPDATE chore_assignments\n    SET \n        assigned_user_id = v_temp_user_id,\n        notes = COALESCE(notes || E'\\n', '') || \n                format('Swapped with user on %s%s', \n                       NOW()::date::text,\n                       CASE WHEN p_reason IS NOT NULL THEN ' - ' || p_reason ELSE '' END),\n        updated_at = NOW()\n    WHERE id = p_assignment2_id;\n    \n    -- Create notifications\n    PERFORM create_household_notification(\n        v_assignment1.household_id,\n        'chores_swapped',\n        'Chores Swapped',\n        format('Chore assignments have been swapped between users'),\n        jsonb_build_object(\n            'assignment1_id', p_assignment1_id,\n            'assignment2_id', p_assignment2_id,\n            'reason', p_reason\n        )\n    );\n    \n    RETURN jsonb_build_object(\n        'success', true,\n        'assignment1_id', p_assignment1_id,\n        'assignment2_id', p_assignment2_id,\n        'message', 'Chores successfully swapped'\n    );\nEND;\n$function$\n"
    },
    {
      "function_name": "send_invitation",
      "comment": "Definition for the send_invitation function.",
      "definition": "CREATE OR REPLACE FUNCTION public.send_invitation(p_household_id uuid, p_email text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_inviter_id UUID;\n  v_invitee_id UUID;\n  v_invitation_id UUID;\n  v_token UUID;\n  v_household_name TEXT;\n  v_inviter_name TEXT;\nBEGIN\n  -- Get the current user\n  v_inviter_id := auth.uid();\n  IF v_inviter_id IS NULL THEN\n    RAISE EXCEPTION 'Not authenticated';\n  END IF;\n\n  -- Check if inviter is a member of the household\n  IF NOT EXISTS (\n    SELECT 1 FROM household_members\n    WHERE household_id = p_household_id\n    AND user_id = v_inviter_id\n  ) THEN\n    RAISE EXCEPTION 'You are not a member of this household';\n  END IF;\n\n  -- Get household name\n  SELECT name INTO v_household_name\n  FROM households\n  WHERE id = p_household_id;\n\n  -- Get inviter name\n  SELECT name INTO v_inviter_name\n  FROM profiles\n  WHERE id = v_inviter_id;\n\n  -- Check if the email belongs to an existing user\n  SELECT id INTO v_invitee_id\n  FROM auth.users\n  WHERE email = LOWER(p_email);\n\n  IF v_invitee_id IS NULL THEN\n    RAISE EXCEPTION 'User not found with email: %. They need to create an account first.', p_email;\n  END IF;\n\n  -- Check if user is already a member\n  IF EXISTS (\n    SELECT 1 FROM household_members\n    WHERE household_id = p_household_id\n    AND user_id = v_invitee_id\n  ) THEN\n    RAISE EXCEPTION 'User is already a member of this household';\n  END IF;\n\n  -- Check if there's already a pending invitation\n  IF EXISTS (\n    SELECT 1 FROM invitations\n    WHERE household_id = p_household_id\n    AND email = LOWER(p_email)\n    AND status = 'pending'\n    AND expires_at > NOW()\n  ) THEN\n    RAISE EXCEPTION 'An invitation already exists for this email';\n  END IF;\n\n  -- Generate a unique token\n  v_token := gen_random_uuid();\n\n  -- Create the invitation\n  INSERT INTO invitations (\n    household_id,\n    invited_by,\n    email,\n    token,\n    status,\n    expires_at\n  ) VALUES (\n    p_household_id,\n    v_inviter_id,\n    LOWER(p_email),\n    v_token,\n    'pending',\n    NOW() + INTERVAL '7 days'\n  ) RETURNING id INTO v_invitation_id;\n\n  -- Create notification for invitee\n  IF v_invitee_id IS NOT NULL THEN\n    INSERT INTO notifications (\n      user_id,\n      household_id,\n      type,\n      title,\n      message,\n      data,\n      is_read\n    ) VALUES (\n      v_invitee_id,\n      p_household_id,\n      'household_invitation',\n      'New Household Invitation',\n      COALESCE(v_inviter_name, 'Someone') || ' has invited you to join ' || COALESCE(v_household_name, 'a household'),\n      jsonb_build_object(\n        'invitation_id', v_invitation_id,\n        'household_id', p_household_id,\n        'inviter_id', v_inviter_id\n      ),\n      false\n    );\n  END IF;\n\n  -- Return success\n  RETURN json_build_object(\n    'success', true,\n    'invitation_id', v_invitation_id,\n    'message', 'Invitation sent successfully'\n  );\n\nEXCEPTION\n  WHEN OTHERS THEN\n    -- Log the error and re-raise with a user-friendly message\n    RAISE EXCEPTION '%', SQLERRM;\nEND;\n$function$\n"
    },
    {
      "function_name": "accept_invitation",
      "comment": "Definition for the accept_invitation function.",
      "definition": "CREATE OR REPLACE FUNCTION public.accept_invitation(p_invitation_id uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_user_id UUID;\n  v_user_email TEXT;\n  v_invitation RECORD;\n  v_household_name TEXT;\n  v_accepter_name TEXT;\nBEGIN\n  -- Get current user\n  v_user_id := auth.uid();\n  IF v_user_id IS NULL THEN\n    RAISE EXCEPTION 'Not authenticated';\n  END IF;\n\n  -- Get user email\n  SELECT email INTO v_user_email\n  FROM auth.users\n  WHERE id = v_user_id;\n\n  -- Get and validate invitation\n  SELECT i.*, h.name as household_name\n  INTO v_invitation\n  FROM invitations i\n  JOIN households h ON i.household_id = h.id\n  WHERE i.id = p_invitation_id\n  AND i.email = v_user_email\n  AND i.status = 'pending';\n\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Invitation not found or not for your email';\n  END IF;\n\n  -- Check if invitation is expired\n  IF v_invitation.expires_at < NOW() THEN\n    -- Update status to expired\n    UPDATE invitations\n    SET status = 'expired', updated_at = NOW()\n    WHERE id = p_invitation_id;\n    \n    RAISE EXCEPTION 'This invitation has expired';\n  END IF;\n\n  -- Check if user is already a member\n  IF EXISTS (\n    SELECT 1 FROM household_members\n    WHERE household_id = v_invitation.household_id\n    AND user_id = v_user_id\n  ) THEN\n    -- Update invitation status\n    UPDATE invitations\n    SET status = 'accepted', updated_at = NOW()\n    WHERE id = p_invitation_id;\n    \n    RAISE EXCEPTION 'You are already a member of this household';\n  END IF;\n\n  -- Add user to household\n  INSERT INTO household_members (\n    household_id,\n    user_id,\n    role,\n    joined_at\n  ) VALUES (\n    v_invitation.household_id,\n    v_user_id,\n    'member',\n    NOW()\n  );\n\n  -- Update invitation status\n  UPDATE invitations\n  SET status = 'accepted', updated_at = NOW()\n  WHERE id = p_invitation_id;\n\n  -- Get accepter name\n  SELECT name INTO v_accepter_name\n  FROM profiles\n  WHERE id = v_user_id;\n\n  -- Notify household members\n  INSERT INTO notifications (\n    user_id,\n    household_id,\n    type,\n    title,\n    message,\n    data,\n    is_read\n  )\n  SELECT \n    hm.user_id,\n    v_invitation.household_id,\n    'member_joined',\n    'New Member Joined',\n    COALESCE(v_accepter_name, 'Someone') || ' has joined ' || v_invitation.household_name,\n    jsonb_build_object(\n      'new_member_id', v_user_id,\n      'household_id', v_invitation.household_id\n    ),\n    false\n  FROM household_members hm\n  WHERE hm.household_id = v_invitation.household_id\n  AND hm.user_id != v_user_id;\n\n  -- Return success\n  RETURN json_build_object(\n    'success', true,\n    'household_id', v_invitation.household_id,\n    'message', 'Successfully joined household'\n  );\n\nEXCEPTION\n  WHEN OTHERS THEN\n    -- Log the error and re-raise\n    RAISE EXCEPTION '%', SQLERRM;\nEND;\n$function$\n"
    },
    {
      "function_name": "cleanup_expired_invitations",
      "comment": "Definition for the cleanup_expired_invitations function.",
      "definition": "CREATE OR REPLACE FUNCTION public.cleanup_expired_invitations()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  UPDATE invitations\n  SET status = 'expired'\n  WHERE status = 'pending'\n  AND expires_at < NOW();\nEND;\n$function$\n"
    },
    {
      "function_name": "delete_household_safely",
      "comment": "Definition for the delete_household_safely function.",
      "definition": "CREATE OR REPLACE FUNCTION public.delete_household_safely(p_household_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Ensure the person calling this is the original creator\n  IF (SELECT created_by FROM households WHERE id = p_household_id) != auth.uid() THEN\n    RAISE EXCEPTION 'Only the original creator can delete this household.';\n  END IF;\n\n  -- Proceed with deletion\n  DELETE FROM households WHERE id = p_household_id;\nEND;\n$function$\n"
    },
    {
      "function_name": "delegate_chore_assignment",
      "comment": "Definition for the delegate_chore_assignment function.",
      "definition": "CREATE OR REPLACE FUNCTION public.delegate_chore_assignment(p_assignment_id uuid, p_new_assignee_id uuid, p_reason text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_assignment RECORD;\n    v_user_id uuid;\n    v_is_admin boolean;\n    v_new_assignee_name text;\n    v_chore_name text;\nBEGIN\n    -- Get current user\n    v_user_id := auth.uid();\n    \n    -- Get assignment details\n    SELECT ca.*, hc.name as chore_name\n    INTO v_assignment\n    FROM chore_assignments ca\n    JOIN household_chores hc ON hc.id = ca.household_chore_id\n    WHERE ca.id = p_assignment_id;\n    \n    -- Validate assignment exists\n    IF v_assignment.id IS NULL THEN\n        RAISE EXCEPTION 'Assignment not found';\n    END IF;\n    \n    -- Check if assignment is pending\n    IF v_assignment.status != 'pending' THEN\n        RAISE EXCEPTION 'Can only delegate pending assignments';\n    END IF;\n    \n    -- Check user permission\n    SELECT role = 'admin' INTO v_is_admin\n    FROM household_members\n    WHERE household_id = v_assignment.household_id\n    AND user_id = v_user_id;\n    \n    IF NOT v_is_admin AND v_assignment.assigned_user_id != v_user_id::text THEN\n        RAISE EXCEPTION 'Only the assigned user or admin can delegate this chore';\n    END IF;\n    \n    -- Validate new assignee is member of household\n    SELECT p.name INTO v_new_assignee_name\n    FROM household_members hm\n    JOIN profiles p ON p.id = hm.user_id\n    WHERE hm.household_id = v_assignment.household_id\n    AND hm.user_id = p_new_assignee_id;\n    \n    IF v_new_assignee_name IS NULL THEN\n        RAISE EXCEPTION 'New assignee must be a member of the household';\n    END IF;\n    \n    -- Update the assignment\n    UPDATE chore_assignments\n    SET \n        assigned_user_id = p_new_assignee_id::text,\n        notes = COALESCE(notes || E'\\n', '') || \n                format('Delegated to %s on %s%s', \n                       v_new_assignee_name,\n                       NOW()::date::text,\n                       CASE WHEN p_reason IS NOT NULL THEN ' - ' || p_reason ELSE '' END),\n        updated_at = NOW()\n    WHERE id = p_assignment_id;\n    \n    -- Notify the new assignee\n    INSERT INTO notifications (user_id, household_id, type, title, message, data)\n    VALUES (\n        p_new_assignee_id,\n        v_assignment.household_id,\n        'chore_delegated',\n        'New Chore Assigned',\n        format('You have been assigned: %s (due %s)', \n               v_assignment.chore_name,\n               v_assignment.due_date::text),\n        jsonb_build_object(\n            'assignment_id', p_assignment_id,\n            'chore_name', v_assignment.chore_name,\n            'due_date', v_assignment.due_date,\n            'delegated_by', v_user_id,\n            'reason', p_reason\n        )\n    );\n    \n    -- Notify household about the delegation\n    PERFORM create_household_notification(\n        v_assignment.household_id,\n        'chore_delegated',\n        'Chore Reassigned',\n        format('\"%s\" has been reassigned to %s', \n               v_assignment.chore_name,\n               v_new_assignee_name),\n        jsonb_build_object(\n            'assignment_id', p_assignment_id,\n            'new_assignee_id', p_new_assignee_id,\n            'reason', p_reason\n        ),\n        p_new_assignee_id -- Exclude the new assignee as they get a specific notification\n    );\n    \n    RETURN jsonb_build_object(\n        'success', true,\n        'assignment_id', p_assignment_id,\n        'new_assignee_id', p_new_assignee_id,\n        'new_assignee_name', v_new_assignee_name,\n        'message', 'Chore successfully delegated'\n    );\nEND;\n$function$\n"
    },
    {
      "function_name": "handle_user_delete",
      "comment": "Definition for the handle_user_delete function.",
      "definition": "CREATE OR REPLACE FUNCTION public.handle_user_delete()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Call our cleanup function\n  PERFORM delete_user_data(OLD.id);\n  RETURN OLD;\nEND;\n$function$\n"
    },
    {
      "function_name": "create_expense_with_splits",
      "comment": "Definition for the create_expense_with_splits function.",
      "definition": "CREATE OR REPLACE FUNCTION public.create_expense_with_splits(p_household_id uuid, p_description text, p_amount numeric, p_paid_by uuid, p_splits jsonb, p_date date DEFAULT CURRENT_DATE)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_expense_id UUID;\n  v_split JSONB;\n  split_count int;\n  single_splitter_id uuid;\n  v_splits_total numeric;\nBEGIN\n  -- VALIDATION: Ensure the sum of split amounts equals the total expense amount.\n  -- This revised version is cleaner and less prone to parsing errors.\n  SELECT SUM(s.amount) INTO v_splits_total\n  FROM jsonb_to_recordset(p_splits) AS s(user_id uuid, amount numeric);\n\n  IF abs(v_splits_total - p_amount) > 0.01 THEN\n    RAISE EXCEPTION 'The sum of split amounts (%) does not match the total expense amount (%).', v_splits_total, p_amount;\n  END IF;\n\n  -- 1. First, check the nature of the split provided by the client.\n  SELECT\n    count(*),\n    (array_agg(s.user_id))[1]\n  INTO\n    split_count,\n    single_splitter_id\n  FROM jsonb_to_recordset(p_splits) AS s(user_id uuid, amount numeric);\n\n  -- 2. Create the base expense record. This happens for all expenses.\n  INSERT INTO expenses (household_id, description, amount, paid_by, date)\n  VALUES (p_household_id, p_description, p_amount, p_paid_by, p_date)\n  RETURNING id INTO v_expense_id;\n\n  -- 3. Only create splits if the expense is meant to be shared.\n  -- A \"personal\" expense is one where the splits array has only one person,\n  -- and that person is the one who paid.\n  IF split_count > 1 OR single_splitter_id IS DISTINCT FROM p_paid_by THEN\n    -- If it's a shared expense, loop through and insert ALL provided splits.\n    -- It's crucial to include the payer's split to calculate balances correctly.\n    FOR v_split IN SELECT * FROM jsonb_array_elements(p_splits) LOOP\n      INSERT INTO expense_splits (expense_id, user_id, amount, settled)\n      VALUES (\n        v_expense_id,\n        (v_split->>'user_id')::UUID,\n        (v_split->>'amount')::DECIMAL(10,2),\n        false\n      );\n    END LOOP;\n  END IF;\n\n  -- 4. Return the new expense ID\n  RETURN v_expense_id;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_database_schema_json",
      "comment": "Definition for the get_database_schema_json function.",
      "definition": "CREATE OR REPLACE FUNCTION public.get_database_schema_json()\n RETURNS json\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    schema_json json;\r\nBEGIN\r\n    SELECT json_build_object(\r\n        'comment', 'This JSON file contains the schema for the public tables, functions, and triggers in the Supabase database. It is intended to be used as context for an LLM.',\r\n        'tables', (\r\n            SELECT json_agg(\r\n                json_build_object(\r\n                    'table_name', t.table_name,\r\n                    'comment', 'Columns for the ' || t.table_name || ' table.',\r\n                    'columns', (\r\n                        SELECT json_agg(\r\n                            json_build_object(\r\n                                'column_name', c.column_name,\r\n                                'data_type', c.data_type\r\n                            )\r\n                        )\r\n                        FROM information_schema.columns c\r\n                        WHERE c.table_schema = 'public' AND c.table_name = t.table_name\r\n                    )\r\n                )\r\n            )\r\n            FROM (SELECT DISTINCT table_name FROM information_schema.columns WHERE table_schema = 'public') AS t\r\n        ),\r\n        'functions', (\r\n            SELECT json_agg(\r\n                json_build_object(\r\n                    'function_name', p.proname,\r\n                    'comment', 'Definition for the ' || p.proname || ' function.',\r\n                    'definition', pg_get_functiondef(p.oid)\r\n                )\r\n            )\r\n            FROM pg_proc p\r\n            JOIN pg_namespace n ON p.pronamespace = n.oid\r\n            WHERE n.nspname = 'public'\r\n        ),\r\n        'triggers', (\r\n            SELECT json_agg(\r\n                json_build_object(\r\n                    'trigger_name', t.trigger_name,\r\n                    'comment', 'Definition for the ' || t.trigger_name || ' trigger.',\r\n                    'table', t.event_object_table,\r\n                    'event', t.event_manipulation,\r\n                    'definition', t.action_statement\r\n                )\r\n            )\r\n            FROM information_schema.triggers t\r\n            WHERE t.trigger_schema = 'public'\r\n        )\r\n    ) INTO schema_json;\r\n\r\n    RETURN schema_json;\r\nEND;\r\n$function$\n"
    },
    {
      "function_name": "get_available_swap_options",
      "comment": "Definition for the get_available_swap_options function.",
      "definition": "CREATE OR REPLACE FUNCTION public.get_available_swap_options(p_assignment_id uuid)\n RETURNS TABLE(assignment_id uuid, chore_name text, assigned_user_id text, assigned_user_name text, due_date date)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_assignment RECORD;\n    v_user_id uuid;\nBEGIN\n    -- Get current user\n    v_user_id := auth.uid();\n    \n    -- Get current assignment\n    SELECT * INTO v_assignment\n    FROM chore_assignments\n    WHERE id = p_assignment_id;\n    \n    -- Return available swaps (same household, pending, different user, within reasonable date range)\n    RETURN QUERY\n    SELECT \n        ca.id as assignment_id,\n        hc.name as chore_name,\n        ca.assigned_user_id,\n        p.name as assigned_user_name,\n        ca.due_date\n    FROM chore_assignments ca\n    JOIN household_chores hc ON hc.id = ca.household_chore_id\n    JOIN profiles p ON p.id = ca.assigned_user_id::uuid\n    WHERE ca.household_id = v_assignment.household_id\n    AND ca.id != p_assignment_id\n    AND ca.status = 'pending'\n    AND ca.assigned_user_id != v_assignment.assigned_user_id\n    AND ca.due_date BETWEEN v_assignment.due_date - INTERVAL '7 days' \n                        AND v_assignment.due_date + INTERVAL '7 days'\n    ORDER BY ca.due_date;\nEND;\n$function$\n"
    },
    {
      "function_name": "assign_placeholder_chores_to_member",
      "comment": "Definition for the assign_placeholder_chores_to_member function.",
      "definition": "CREATE OR REPLACE FUNCTION public.assign_placeholder_chores_to_member(p_household_id uuid, p_user_id uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_assignments_updated integer;\n    v_member_count integer;\n    v_placeholder_count integer;\nBEGIN\n    -- Count current members\n    SELECT COUNT(*) INTO v_member_count\n    FROM household_members\n    WHERE household_id = p_household_id;\n    \n    -- Count placeholder assignments (null or empty assigned_user_id)\n    SELECT COUNT(*) INTO v_placeholder_count\n    FROM chore_assignments\n    WHERE household_id = p_household_id\n    AND status = 'pending'\n    AND (assigned_user_id IS NULL OR assigned_user_id = '');\n    \n    -- If there are placeholders, assign them using round-robin\n    IF v_placeholder_count > 0 THEN\n        -- Update placeholder assignments\n        WITH numbered_placeholders AS (\n            SELECT id, ROW_NUMBER() OVER (ORDER BY due_date, id) as rn\n            FROM chore_assignments\n            WHERE household_id = p_household_id\n            AND status = 'pending'\n            AND (assigned_user_id IS NULL OR assigned_user_id = '')\n        ),\n        member_position AS (\n            SELECT COUNT(*) as position\n            FROM household_members\n            WHERE household_id = p_household_id\n            AND joined_at < (SELECT joined_at FROM household_members \n                           WHERE household_id = p_household_id AND user_id = p_user_id)\n        )\n        UPDATE chore_assignments ca\n        SET \n            assigned_user_id = p_user_id::text,\n            notes = COALESCE(notes || E'\\n', '') || \n                   format('Auto-assigned to new member on %s', NOW()::date::text),\n            updated_at = NOW()\n        FROM numbered_placeholders np, member_position mp\n        WHERE ca.id = np.id\n        AND (np.rn - 1) % v_member_count = mp.position;\n        \n        GET DIAGNOSTICS v_assignments_updated = ROW_COUNT;\n    ELSE\n        v_assignments_updated := 0;\n    END IF;\n    \n    -- Create notification for the new member\n    IF v_assignments_updated > 0 THEN\n        INSERT INTO notifications (user_id, household_id, type, title, message, data)\n        VALUES (\n            p_user_id,\n            p_household_id,\n            'chores_assigned',\n            'Chores Assigned',\n            format('You have been assigned %s chore(s)', v_assignments_updated),\n            jsonb_build_object(\n                'count', v_assignments_updated\n            )\n        );\n    END IF;\n    \n    RETURN jsonb_build_object(\n        'success', true,\n        'assignments_updated', v_assignments_updated,\n        'message', format('%s chores assigned to new member', v_assignments_updated)\n    );\nEND;\n$function$\n"
    },
    {
      "function_name": "calculate_household_balances",
      "comment": "Definition for the calculate_household_balances function.",
      "definition": "CREATE OR REPLACE FUNCTION public.calculate_household_balances(p_household_id uuid)\n RETURNS TABLE(userid uuid, balance numeric, profile json)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT\r\n    m.user_id,\r\n    -- The final, robust balance formula:\r\n    (COALESCE(e.paid, 0) - COALESCE(s.owed_unsettled, 0) + COALESCE(adj.adjustments_balance, 0) + COALESCE(se.settled_balance, 0)) AS balance,\r\n    json_build_object('id', p.id, 'name', p.name, 'avatar_url', p.avatar_url) as profile\r\n  FROM household_members m\r\n  JOIN profiles p ON m.user_id = p.id\r\n\r\n  -- 1. Get total amount each user has paid for shared expenses\r\n  LEFT JOIN (\r\n    SELECT paid_by, SUM(amount) as paid\r\n    FROM expenses\r\n    WHERE household_id = p_household_id AND id IN (SELECT DISTINCT expense_id FROM expense_splits WHERE expense_splits.expense_id IS NOT NULL)\r\n    GROUP BY paid_by\r\n  ) e ON m.user_id = e.paid_by\r\n\r\n  -- 2. Get total amount each user owes from their UNSETTLED share of expenses\r\n  LEFT JOIN (\r\n    SELECT\r\n        es.user_id,\r\n        SUM(es.amount) as owed_unsettled\r\n    FROM expense_splits es\r\n    JOIN expenses ex ON es.expense_id = ex.id\r\n    WHERE ex.household_id = p_household_id AND es.settled = false\r\n    GROUP BY es.user_id\r\n  ) s ON m.user_id = s.user_id\r\n\r\n  -- 3. Get net balance from adjustments on SETTLED splits (Corrected Logic)\r\n  LEFT JOIN (\r\n    SELECT\r\n      u.user_id,\r\n      SUM(CASE\r\n        -- If I was the original Payer, the adjustment amount increases my credit (positive)\r\n        WHEN ex.paid_by = u.user_id THEN -adj.adjustment_amount\r\n        -- If I was the one who owed money, the adjustment amount increases my debt (negative)\r\n        WHEN es.user_id = u.user_id THEN adj.adjustment_amount\r\n        ELSE 0\r\n      END) as adjustments_balance\r\n    FROM public.expense_split_adjustments adj\r\n    JOIN public.expense_splits es ON adj.expense_split_id = es.id\r\n    JOIN public.expenses ex ON es.expense_id = ex.id\r\n    JOIN public.household_members u ON u.household_id = ex.household_id AND (u.user_id = es.user_id OR u.user_id = ex.paid_by)\r\n    WHERE ex.household_id = p_household_id\r\n    GROUP BY u.user_id\r\n  ) adj ON m.user_id = adj.user_id\r\n\r\n  -- 4. Get net balance from all settlements (Corrected Logic)\r\n  LEFT JOIN (\r\n    SELECT\r\n      user_id,\r\n      SUM(transaction_amount) as settled_balance\r\n    FROM (\r\n      -- Add amounts for payments made by the user (clears their debt, so it's a positive change to their balance)\r\n      SELECT payer_id as user_id, amount as transaction_amount FROM settlements WHERE household_id = p_household_id\r\n      UNION ALL\r\n      -- Subtract amounts for payments received by the user (reduces what they are owed, so it's a negative change to their balance)\r\n      SELECT payee_id as user_id, -amount as transaction_amount FROM settlements WHERE household_id = p_household_id\r\n    ) AS settlement_transactions\r\n    GROUP BY user_id\r\n  ) se ON m.user_id = se.user_id\r\n\r\n  WHERE m.household_id = p_household_id;\r\nEND;\r\n$function$\n"
    },
    {
      "function_name": "create_expense_atomic",
      "comment": "Definition for the create_expense_atomic function.",
      "definition": "CREATE OR REPLACE FUNCTION public.create_expense_atomic(p_household_id uuid, p_description text, p_amount numeric, p_payments jsonb, p_splits jsonb, p_date date DEFAULT CURRENT_DATE, p_client_uuid uuid DEFAULT NULL::uuid, p_recurring_expense_id uuid DEFAULT NULL::uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_expense_id uuid;\n    v_payment record;\n    v_split record;\n    v_total_paid numeric := 0;\n    v_total_split numeric := 0;\n    v_request_hash text;\n    v_existing_expense_id uuid;\nBEGIN\n    -- Generate request hash for idempotency check\n    v_request_hash := encode(sha256(\n        concat(\n            p_household_id::text,\n            p_description,\n            p_amount::text,\n            p_payments::text,\n            p_splits::text,\n            p_date::text\n        )::bytea\n    ), 'hex');\n\n    -- Check idempotency if client_uuid provided\n    IF p_client_uuid IS NOT NULL THEN\n        SELECT expense_id INTO v_existing_expense_id\n        FROM public.expense_idempotency\n        WHERE client_uuid = p_client_uuid;\n        \n        IF v_existing_expense_id IS NOT NULL THEN\n            RETURN jsonb_build_object(\n                'success', true,\n                'expense_id', v_existing_expense_id,\n                'idempotent', true,\n                'message', 'Expense already created with this request'\n            );\n        END IF;\n    END IF;\n\n    -- Validate payments sum\n    SELECT SUM((p->>'amount')::numeric) INTO v_total_paid\n    FROM jsonb_array_elements(p_payments) p;\n    \n    IF abs(v_total_paid - p_amount) > 0.01 THEN\n        RAISE EXCEPTION 'Payment amounts (%) do not match expense amount (%)', \n            v_total_paid, p_amount;\n    END IF;\n\n    -- Validate splits sum\n    SELECT SUM((s->>'amount')::numeric) INTO v_total_split\n    FROM jsonb_array_elements(p_splits) s;\n    \n    IF abs(v_total_split - p_amount) > 0.01 THEN\n        RAISE EXCEPTION 'Split amounts (%) do not match expense amount (%)', \n            v_total_split, p_amount;\n    END IF;\n\n    -- Start transaction block\n    BEGIN\n        -- Create expense (paid_by will be primary payer)\n        INSERT INTO public.expenses (\n            household_id, \n            description, \n            amount, \n            paid_by, \n            date,\n            recurring_expense_id\n        )\n        VALUES (\n            p_household_id, \n            p_description, \n            p_amount, \n            (p_payments->0->>'payer_id')::uuid,  -- First payer as primary\n            p_date,\n            p_recurring_expense_id\n        )\n        RETURNING id INTO v_expense_id;\n\n        -- Insert all payments\n        FOR v_payment IN \n            SELECT * FROM jsonb_to_recordset(p_payments) \n            AS x(payer_id uuid, amount numeric)\n        LOOP\n            INSERT INTO public.expense_payments (expense_id, payer_id, amount)\n            VALUES (v_expense_id, v_payment.payer_id, v_payment.amount);\n            \n            -- Update ledger for payer (positive balance = credit)\n            PERFORM update_ledger_balance(\n                p_household_id, \n                v_payment.payer_id, \n                v_payment.amount\n            );\n        END LOOP;\n\n        -- Insert all splits\n        FOR v_split IN \n            SELECT * FROM jsonb_to_recordset(p_splits) \n            AS x(user_id uuid, amount numeric)\n        LOOP\n            -- Check if this user is also a payer\n            DECLARE\n                v_paid_amount numeric;\n            BEGIN\n                SELECT COALESCE(SUM(amount), 0) INTO v_paid_amount\n                FROM jsonb_to_recordset(p_payments) AS p(payer_id uuid, amount numeric)\n                WHERE p.payer_id = v_split.user_id;\n                \n                INSERT INTO public.expense_splits (\n                    expense_id, \n                    user_id, \n                    amount,\n                    settled\n                )\n                VALUES (\n                    v_expense_id, \n                    v_split.user_id, \n                    v_split.amount,\n                    v_paid_amount >= v_split.amount  -- Auto-settle if paid >= owed\n                );\n                \n                -- Update ledger for split (negative balance = debt)\n                PERFORM update_ledger_balance(\n                    p_household_id, \n                    v_split.user_id, \n                    -v_split.amount\n                );\n            END;\n        END LOOP;\n\n        -- Record idempotency if client_uuid provided\n        IF p_client_uuid IS NOT NULL THEN\n            INSERT INTO public.expense_idempotency (\n                client_uuid, \n                expense_id, \n                request_hash\n            )\n            VALUES (p_client_uuid, v_expense_id, v_request_hash);\n        END IF;\n\n        RETURN jsonb_build_object(\n            'success', true,\n            'expense_id', v_expense_id,\n            'idempotent', false,\n            'message', 'Expense created successfully'\n        );\n        \n    EXCEPTION WHEN OTHERS THEN\n        RAISE EXCEPTION 'Failed to create expense: %', SQLERRM;\n    END;\nEND;\n$function$\n"
    },
    {
      "function_name": "ensure_lowercase_email",
      "comment": "Definition for the ensure_lowercase_email function.",
      "definition": "CREATE OR REPLACE FUNCTION public.ensure_lowercase_email()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  NEW.email = LOWER(TRIM(NEW.email));\n  RETURN NEW;\nEND;\n$function$\n"
    },
    {
      "function_name": "create_settlement",
      "comment": "Definition for the create_settlement function.",
      "definition": "CREATE OR REPLACE FUNCTION public.create_settlement(p_household_id uuid, p_payer_id uuid, p_payee_id uuid, p_amount numeric, p_description text)\n RETURNS SETOF settlements\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$DECLARE\n  new_settlement settlements;\nBEGIN\n  -- Verify the payer is a member of the household\n  IF NOT EXISTS (\n    SELECT 1 FROM household_members \n    WHERE household_id = p_household_id \n    AND user_id = p_payer_id\n  ) THEN\n    RAISE EXCEPTION 'Payer is not a member of this household';\n  END IF;\n\n  -- Verify the payee is a member of the household\n  IF NOT EXISTS (\n    SELECT 1 FROM household_members \n    WHERE household_id = p_household_id \n    AND user_id = p_payee_id\n  ) THEN\n    RAISE EXCEPTION 'Payee is not a member of this household';\n  END IF;\n\n  -- Prevent self-payments\n  IF p_payer_id = p_payee_id THEN\n    RAISE EXCEPTION 'Cannot create a payment to yourself';\n  END IF;\n\n  -- Insert the settlement. The trigger will handle the notification.\n  INSERT INTO public.settlements (household_id, payer_id, payee_id, amount, description)\n  VALUES (p_household_id, p_payer_id, p_payee_id, p_amount, p_description)\n  RETURNING * INTO new_settlement;\n\n  RETURN NEXT new_settlement;\nEND;$function$\n"
    },
    {
      "function_name": "process_recurring_expenses_robust",
      "comment": "Definition for the process_recurring_expenses_robust function.",
      "definition": "CREATE OR REPLACE FUNCTION public.process_recurring_expenses_robust(p_household_id uuid DEFAULT NULL::uuid, p_batch_size integer DEFAULT 100)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_processed_count integer := 0;\n    v_error_count integer := 0;\n    v_recurring record;\n    v_payments jsonb;\n    v_splits jsonb;\n    v_next_date date;\n    v_result jsonb;\nBEGIN\n    -- Process recurring expenses with row-level locking\n    FOR v_recurring IN\n        SELECT * FROM public.recurring_expenses\n        WHERE is_active = true\n        AND next_due_date <= CURRENT_DATE\n        AND (p_household_id IS NULL OR household_id = p_household_id)\n        AND (last_processed_at IS NULL OR last_processed_at < next_due_date)\n        ORDER BY next_due_date, id\n        LIMIT p_batch_size\n        FOR UPDATE SKIP LOCKED\n    LOOP\n        BEGIN\n            -- Prepare payment (single payer for recurring)\n            v_payments := jsonb_build_array(\n                jsonb_build_object(\n                    'payer_id', v_recurring.created_by,\n                    'amount', v_recurring.amount\n                )\n            );\n            \n            -- Use custom splits or calculate equal splits\n            IF v_recurring.splits IS NOT NULL AND jsonb_array_length(v_recurring.splits) > 0 THEN\n                v_splits := v_recurring.splits;\n            ELSE\n                -- Equal split among all household members\n                SELECT jsonb_agg(\n                    jsonb_build_object(\n                        'user_id', hm.user_id,\n                        'amount', round(v_recurring.amount / COUNT(*) OVER(), 2)\n                    )\n                ) INTO v_splits\n                FROM public.household_members hm\n                WHERE hm.household_id = v_recurring.household_id;\n            END IF;\n            \n            -- Create expense atomically\n            v_result := create_expense_atomic(\n                v_recurring.household_id,\n                v_recurring.description || ' (Recurring)',\n                v_recurring.amount,\n                v_payments,\n                v_splits,\n                v_recurring.next_due_date,\n                NULL,  -- No client_uuid for system-generated\n                v_recurring.id\n            );\n            \n            -- Calculate next due date based on frequency\n            v_next_date := CASE v_recurring.frequency\n                WHEN 'daily' THEN v_recurring.next_due_date + INTERVAL '1 day'\n                WHEN 'weekly' THEN v_recurring.next_due_date + INTERVAL '1 week'\n                WHEN 'biweekly' THEN v_recurring.next_due_date + INTERVAL '2 weeks'\n                WHEN 'monthly' THEN \n                    -- Handle month-end dates properly\n                    CASE \n                        WHEN v_recurring.day_of_month > 28 THEN\n                            (v_recurring.next_due_date + INTERVAL '1 month')::date - \n                            ((v_recurring.day_of_month - EXTRACT(DAY FROM \n                                (v_recurring.next_due_date + INTERVAL '1 month')::date\n                            ))::integer || ' days')::interval\n                        ELSE\n                            v_recurring.next_due_date + INTERVAL '1 month'\n                    END\n                WHEN 'quarterly' THEN v_recurring.next_due_date + INTERVAL '3 months'\n                WHEN 'yearly' THEN v_recurring.next_due_date + INTERVAL '1 year'\n                ELSE v_recurring.next_due_date + INTERVAL '1 month'\n            END;\n            \n            -- Update recurring expense\n            UPDATE public.recurring_expenses\n            SET \n                next_due_date = v_next_date,\n                last_processed_at = NOW(),\n                updated_at = NOW()\n            WHERE id = v_recurring.id;\n            \n            v_processed_count := v_processed_count + 1;\n            \n        EXCEPTION WHEN OTHERS THEN\n            -- Log error but continue processing\n            v_error_count := v_error_count + 1;\n            RAISE WARNING 'Failed to process recurring expense %: %', \n                v_recurring.id, SQLERRM;\n        END;\n    END LOOP;\n    \n    RETURN jsonb_build_object(\n        'success', true,\n        'processed', v_processed_count,\n        'errors', v_error_count,\n        'message', format('Processed %s recurring expenses with %s errors', \n            v_processed_count, v_error_count)\n    );\nEND;\n$function$\n"
    },
    {
      "function_name": "get_messages_with_profiles",
      "comment": "Definition for the get_messages_with_profiles function.",
      "definition": "CREATE OR REPLACE FUNCTION public.get_messages_with_profiles(p_household_id uuid, p_limit integer DEFAULT 50, p_before timestamp with time zone DEFAULT NULL::timestamp with time zone)\n RETURNS TABLE(id uuid, household_id uuid, user_id uuid, content text, edited boolean, deleted boolean, created_at timestamp with time zone, updated_at timestamp with time zone, profile json)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    m.id,\n    m.household_id,\n    m.user_id,\n    m.content,\n    m.edited,\n    m.deleted,\n    m.created_at,\n    m.updated_at,\n    row_to_json(p.*) as profile\n  FROM messages m\n  LEFT JOIN profiles p ON p.id = m.user_id\n  WHERE m.household_id = p_household_id\n    AND m.deleted = FALSE\n    AND (p_before IS NULL OR m.created_at < p_before)\n  ORDER BY m.created_at DESC\n  LIMIT p_limit;\nEND;\n$function$\n"
    },
    {
      "function_name": "handle_user_deletion",
      "comment": "Definition for the handle_user_deletion function.",
      "definition": "CREATE OR REPLACE FUNCTION public.handle_user_deletion(p_email text)\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'auth'\nAS $function$DECLARE\n    v_user_id UUID;\n    v_deleted_count INT := 0;\n    v_result TEXT := '';\nBEGIN\n    -- Get user ID\n    SELECT id INTO v_user_id FROM auth.users WHERE email = p_email;\n    \n    IF v_user_id IS NULL THEN\n        RETURN 'User not found with email: ' || p_email;\n    END IF;\n    \n    -- Start cleanup\n    v_result := 'Starting cleanup for user: ' || v_user_id || E'\\n';\n    \n    -- Delete from notifications\n    DELETE FROM public.notifications WHERE user_id = v_user_id;\n    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;\n    v_result := v_result || 'Deleted ' || v_deleted_count || ' notifications' || E'\\n';\n    \n    -- Delete from expense_splits\n    DELETE FROM public.expense_splits WHERE user_id = v_user_id;\n    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;\n    v_result := v_result || 'Deleted ' || v_deleted_count || ' expense splits' || E'\\n';\n    \n    -- Update tasks (remove assignment)\n    UPDATE public.tasks SET assigned_to = NULL WHERE assigned_to = v_user_id;\n    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;\n    v_result := v_result || 'Updated ' || v_deleted_count || ' tasks' || E'\\n';\n    \n    -- Delete settlements\n    DELETE FROM public.settlements WHERE payer_id = v_user_id OR payee_id = v_user_id;\n    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;\n    v_result := v_result || 'Deleted ' || v_deleted_count || ' settlements' || E'\\n';\n    \n    -- Update invitations\n    UPDATE public.invitations SET invited_by = NULL WHERE invited_by = v_user_id;\n    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;\n    v_result := v_result || 'Updated ' || v_deleted_count || ' invitations' || E'\\n';\n    \n    -- Delete from household_members\n    DELETE FROM public.household_members WHERE user_id = v_user_id;\n    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;\n    v_result := v_result || 'Deleted ' || v_deleted_count || ' household memberships' || E'\\n';\n    \n    -- Delete expenses\n    DELETE FROM public.expenses WHERE paid_by = v_user_id;\n    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;\n    v_result := v_result || 'Deleted ' || v_deleted_count || ' expenses' || E'\\n';\n    \n    -- Delete recurring expenses\n    DELETE FROM public.recurring_expenses WHERE created_by = v_user_id;\n    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;\n    v_result := v_result || 'Deleted ' || v_deleted_count || ' recurring expenses' || E'\\n';\n    \n    -- Update households (if user created any)\n    UPDATE public.households SET created_by = NULL WHERE created_by = v_user_id;\n    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;\n    v_result := v_result || 'Updated ' || v_deleted_count || ' households' || E'\\n';\n    \n    -- Delete profile\n    DELETE FROM public.profiles WHERE id = v_user_id;\n    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;\n    v_result := v_result || 'Deleted ' || v_deleted_count || ' profiles' || E'\\n';\n    \n    -- Finally, delete from auth.users\n    DELETE FROM auth.users WHERE id = v_user_id;\n    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;\n    v_result := v_result || 'Deleted ' || v_deleted_count || ' auth.users records' || E'\\n';\n    \n    RETURN v_result || E'\\nUser deletion completed successfully!';\n    \nEXCEPTION\n    WHEN foreign_key_violation THEN\n        RETURN 'Foreign key violation: ' || SQLERRM || E'\\n' || v_result;\n    WHEN OTHERS THEN\n        RETURN 'Error: ' || SQLERRM || E'\\n' || v_result;\nEND;$function$\n"
    },
    {
      "function_name": "process_due_recurring_expenses",
      "comment": "Definition for the process_due_recurring_expenses function.",
      "definition": "CREATE OR REPLACE FUNCTION public.process_due_recurring_expenses(p_household_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    recurring_expense RECORD;\r\n    household_members RECORD;\r\n    new_expense_id uuid;\r\n    member_count INT;\r\n    split_amount NUMERIC;\r\n    v_split JSONB;\r\n    v_next_due_date DATE;\r\nBEGIN\r\n    FOR recurring_expense IN\r\n        SELECT *\r\n        FROM public.recurring_expenses\r\n        WHERE household_id = p_household_id\r\n          AND is_active = TRUE\r\n          AND next_due_date <= CURRENT_DATE\r\n    LOOP\r\n        INSERT INTO public.expenses(household_id, description, amount, paid_by, date)\r\n        VALUES (recurring_expense.household_id, recurring_expense.description, recurring_expense.amount, recurring_expense.created_by, recurring_expense.next_due_date)\r\n        RETURNING id INTO new_expense_id;\r\n\r\n        -- Check if custom splits are defined\r\n        IF recurring_expense.splits IS NOT NULL AND jsonb_array_length(recurring_expense.splits) > 0 THEN\r\n            -- Use custom splits\r\n            FOR v_split IN SELECT * FROM jsonb_array_elements(recurring_expense.splits)\r\n            LOOP\r\n                INSERT INTO public.expense_splits(expense_id, user_id, amount, settled)\r\n                VALUES (\r\n                    new_expense_id,\r\n                    (v_split->>'user_id')::UUID,\r\n                    (v_split->>'amount')::NUMERIC,\r\n                    (v_split->>'user_id')::UUID = recurring_expense.created_by\r\n                );\r\n            END LOOP;\r\n        ELSE\r\n            -- Fallback to equal split\r\n            SELECT count(*) INTO member_count FROM public.household_members WHERE household_id = recurring_expense.household_id;\r\n            IF member_count > 0 THEN\r\n                split_amount := round(recurring_expense.amount / member_count, 2);\r\n\r\n                FOR household_members IN\r\n                    SELECT user_id FROM public.household_members WHERE household_id = recurring_expense.household_id\r\n                LOOP\r\n                    INSERT INTO public.expense_splits(expense_id, user_id, amount, settled)\r\n                    VALUES (\r\n                        new_expense_id,\r\n                        household_members.user_id,\r\n                        split_amount,\r\n                        household_members.user_id = recurring_expense.created_by\r\n                    );\r\n                END LOOP;\r\n            END IF;\r\n        END IF;\r\n\r\n        -- Calculate and update the next due date\r\n        v_next_due_date := CASE recurring_expense.frequency\r\n            WHEN 'weekly' THEN recurring_expense.next_due_date + INTERVAL '1 week'\r\n            WHEN 'biweekly' THEN recurring_expense.next_due_date + INTERVAL '2 weeks'\r\n            WHEN 'monthly' THEN recurring_expense.next_due_date + INTERVAL '1 month'\r\n            WHEN 'quarterly' THEN recurring_expense.next_due_date + INTERVAL '3 months'\r\n            WHEN 'yearly' THEN recurring_expense.next_due_date + INTERVAL '1 year'\r\n            ELSE recurring_expense.next_due_date + INTERVAL '1 month'\r\n        END;\r\n\r\n        UPDATE public.recurring_expenses\r\n        SET next_due_date = v_next_due_date\r\n        WHERE id = recurring_expense.id;\r\n    END LOOP;\r\nEND;\r\n$function$\n"
    },
    {
      "function_name": "trigger_update_ledger_on_settlement",
      "comment": "Definition for the trigger_update_ledger_on_settlement function.",
      "definition": "CREATE OR REPLACE FUNCTION public.trigger_update_ledger_on_settlement()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- When a settlement is created, update ledger balances\n    -- Payer's balance increases (they paid off debt)\n    PERFORM update_ledger_balance(\n        NEW.household_id,\n        NEW.payer_id,\n        NEW.amount\n    );\n    \n    -- Payee's balance decreases (they received payment)\n    PERFORM update_ledger_balance(\n        NEW.household_id,\n        NEW.payee_id,\n        -NEW.amount\n    );\n    \n    RETURN NEW;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_household_balances_fast",
      "comment": "Definition for the get_household_balances_fast function.",
      "definition": "CREATE OR REPLACE FUNCTION public.get_household_balances_fast(p_household_id uuid)\n RETURNS TABLE(user_id uuid, balance numeric, profile jsonb, last_updated timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        lb.user_id,\n        lb.balance,\n        jsonb_build_object(\n            'id', p.id,\n            'name', p.name,\n            'avatar_url', p.avatar_url,\n            'email', p.email\n        ) as profile,\n        lb.last_updated_at\n    FROM public.ledger_balances lb\n    JOIN public.profiles p ON lb.user_id = p.id\n    WHERE lb.household_id = p_household_id\n    AND lb.balance != 0  -- Only return non-zero balances\n    ORDER BY abs(lb.balance) DESC;\nEND;\n$function$\n"
    },
    {
      "function_name": "update_expense_with_splits_smart",
      "comment": "Definition for the update_expense_with_splits_smart function.",
      "definition": "CREATE OR REPLACE FUNCTION public.update_expense_with_splits_smart(p_expense_id uuid, p_description text, p_amount numeric, p_splits jsonb, p_paid_by uuid, p_date date)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$DECLARE\r\n    v_old_expense RECORD;\r\n    v_existing_split RECORD;\r\n    v_new_split jsonb;\r\n    v_adjustment_amount numeric;\r\nBEGIN\r\n    -- Get the old expense data\r\n    SELECT * INTO v_old_expense FROM public.expenses WHERE id = p_expense_id;\r\n\r\n    -- Update the main expense record\r\n    UPDATE public.expenses\r\n    SET\r\n        description = p_description,\r\n        amount = p_amount,\r\n        paid_by = p_paid_by,\r\n        date = p_date,\r\n        updated_at = now()\r\n    WHERE id = p_expense_id;\r\n\r\n    -- Loop through the new splits\r\n    FOR v_new_split IN SELECT * FROM jsonb_array_elements(p_splits) LOOP\r\n    SELECT * INTO v_existing_split\r\n        FROM public.expense_splits\r\n    WHERE expense_id = p_expense_id\r\n        AND user_id    = (v_new_split->>'user_id')::uuid;\r\n\r\n    IF FOUND THEN\r\n        -- only adjust splits that were settled AND do not belong to the original payer\r\n        IF v_existing_split.settled\r\n        AND v_existing_split.amount <> (v_new_split->>'amount')::numeric\r\n        AND v_existing_split.user_id <> v_old_expense.paid_by\r\n        THEN\r\n        v_adjustment_amount := (v_new_split->>'amount')::numeric - v_existing_split.amount;\r\n        INSERT INTO public.expense_split_adjustments\r\n            (expense_split_id, adjustment_amount, reason, created_by)\r\n        VALUES\r\n            (v_existing_split.id, v_adjustment_amount, 'Expense edited after settlement', auth.uid());\r\n        ELSIF NOT v_existing_split.settled THEN\r\n        UPDATE public.expense_splits\r\n            SET amount = (v_new_split->>'amount')::numeric\r\n        WHERE id = v_existing_split.id;\r\n        END IF;\r\n    ELSE\r\n        INSERT INTO public.expense_splits (expense_id, user_id, amount, settled)\r\n        VALUES (\r\n        p_expense_id,\r\n        (v_new_split->>'user_id')::uuid,\r\n        (v_new_split->>'amount')::numeric,\r\n        false\r\n        );\r\n    END IF;\r\n    END LOOP;\r\n\r\n    -- Handle removed splits\r\n    FOR v_existing_split IN\r\n        SELECT * FROM public.expense_splits\r\n        WHERE expense_id = p_expense_id\r\n        AND user_id NOT IN (SELECT (s->>'user_id')::uuid FROM jsonb_array_elements(p_splits) s)\r\n    LOOP\r\n        IF v_existing_split.settled THEN\r\n            -- If the removed split was settled, create a negative adjustment\r\n            INSERT INTO public.expense_split_adjustments\r\n                (expense_split_id, adjustment_amount, reason, created_by)\r\n            VALUES\r\n                (v_existing_split.id, -v_existing_split.amount, 'User removed from expense after settlement', auth.uid());\r\n        ELSE\r\n            -- If not settled, just delete the split\r\n            DELETE FROM public.expense_splits WHERE id = v_existing_split.id;\r\n        END IF;\r\n    END LOOP;\r\n\r\n    RETURN jsonb_build_object(\r\n        'success', true,\r\n        'message', 'Expense updated successfully.'\r\n    );\r\nEND;$function$\n"
    },
    {
      "function_name": "cleanup_old_idempotency_records",
      "comment": "Definition for the cleanup_old_idempotency_records function.",
      "definition": "CREATE OR REPLACE FUNCTION public.cleanup_old_idempotency_records()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    DELETE FROM public.expense_idempotency\n    WHERE created_at < NOW() - INTERVAL '7 days';\nEND;\n$function$\n"
    },
    {
      "function_name": "initialize_ledger_balances",
      "comment": "Definition for the initialize_ledger_balances function.",
      "definition": "CREATE OR REPLACE FUNCTION public.initialize_ledger_balances()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    v_household record;\n    v_balance record;\nBEGIN\n    -- Process each household\n    FOR v_household IN\n        SELECT DISTINCT household_id FROM public.household_members\n    LOOP\n        -- Calculate and insert balances\n        FOR v_balance IN\n            SELECT * FROM calculate_household_balances(v_household.household_id)\n        LOOP\n            INSERT INTO public.ledger_balances (\n                household_id, \n                user_id, \n                balance\n            )\n            VALUES (\n                v_household.household_id,\n                v_balance.userid,\n                v_balance.balance\n            )\n            ON CONFLICT (household_id, user_id) DO UPDATE\n            SET balance = EXCLUDED.balance;\n        END LOOP;\n    END LOOP;\nEND;\n$function$\n"
    },
    {
      "function_name": "notify_new_message_with_profile",
      "comment": "Definition for the notify_new_message_with_profile function.",
      "definition": "CREATE OR REPLACE FUNCTION public.notify_new_message_with_profile()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  profile_data json;\nBEGIN\n  -- Get the profile of the user who sent the message\n  SELECT json_build_object(\n    'id', id,\n    'name', name,\n    'avatar_url', avatar_url\n  ) INTO profile_data\n  FROM public.profiles\n  WHERE id = NEW.user_id;\n\n  -- Send a notification on the 'new_message' channel with a combined payload\n  PERFORM pg_notify(\n    'new_message',\n    json_build_object(\n      'message', row_to_json(NEW),\n      'profile', profile_data\n    )::text\n  );\n\n  RETURN NEW;\nEND;\n$function$\n"
    },
    {
      "function_name": "check_user_deletion_setup",
      "comment": "Definition for the check_user_deletion_setup function.",
      "definition": "CREATE OR REPLACE FUNCTION public.check_user_deletion_setup()\n RETURNS TABLE(check_item text, status text, details text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Check if trigger exists\n    RETURN QUERY\n    SELECT \n        'User deletion trigger'::TEXT,\n        CASE WHEN EXISTS (\n            SELECT 1 FROM pg_trigger \n            WHERE tgname = 'before_user_delete' \n            AND tgrelid = 'auth.users'::regclass\n        ) THEN 'OK' ELSE 'MISSING' END,\n        'Trigger to clean up user data before deletion'::TEXT;\n    \n    -- Check foreign key constraints\n    RETURN QUERY\n    SELECT \n        format('FK: %s.%s', tc.table_name, tc.constraint_name)::TEXT,\n        format('%s on delete', rc.delete_rule)::TEXT,\n        format('Column %s -> auth.users', kcu.column_name)::TEXT\n    FROM \n        information_schema.table_constraints AS tc \n        JOIN information_schema.key_column_usage AS kcu\n          ON tc.constraint_name = kcu.constraint_name\n          AND tc.table_schema = kcu.table_schema\n        JOIN information_schema.referential_constraints AS rc\n          ON tc.constraint_name = rc.constraint_name\n          AND tc.table_schema = rc.constraint_schema\n        JOIN information_schema.constraint_column_usage AS ccu\n          ON rc.unique_constraint_name = ccu.constraint_name\n    WHERE tc.constraint_type = 'FOREIGN KEY' \n        AND ccu.table_schema = 'auth'\n        AND ccu.table_name = 'users'\n        AND tc.table_schema = 'public'\n    ORDER BY tc.table_name, tc.constraint_name;\n    \nEND;\n$function$\n"
    },
    {
      "function_name": "handle_updated_at",
      "comment": "Definition for the handle_updated_at function.",
      "definition": "CREATE OR REPLACE FUNCTION public.handle_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  NEW.updated_at = TIMEZONE('utc', NOW());\n  RETURN NEW;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_household_data",
      "comment": "Definition for the get_household_data function.",
      "definition": "CREATE OR REPLACE FUNCTION public.get_household_data(p_household_id uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$-- FILEPATH: supabase>database>functions>get_household_data (Updated)\nDECLARE\n  result JSON;\nBEGIN\n  SELECT json_build_object(\n    'household', (\n      SELECT row_to_json(h.*)\n      FROM households h\n      WHERE h.id = p_household_id\n    ),\n    'members', (\n      SELECT COALESCE(json_agg(\n        json_build_object(\n          'id', hm.id,\n          'household_id', hm.household_id,\n          'user_id', hm.user_id,\n          'role', hm.role,\n          'joined_at', hm.joined_at,\n          'profiles', row_to_json(p.*)\n        )\n      ), '[]'::json)\n      FROM household_members hm\n      JOIN profiles p ON p.id = hm.user_id\n      WHERE hm.household_id = p_household_id\n    ),\n    'recent_expenses', (\n      SELECT COALESCE(json_agg(\n        json_build_object(\n          'id', e.id,\n          'household_id', e.household_id,\n          'description', e.description,\n          'amount', e.amount,\n          'paid_by', e.paid_by,\n          'date', e.date,\n          'created_at', e.created_at,\n          'updated_at', e.updated_at,\n          'profiles', row_to_json(p.*),\n          'expense_splits', (\n            SELECT json_agg(\n              json_build_object(\n                'id', es.id,\n                'expense_id', es.expense_id,\n                'user_id', es.user_id,\n                'amount', es.amount,\n                'settled', es.settled,\n                'settled_at', es.settled_at,\n                'profiles', row_to_json(sp.*)\n              )\n            )\n            FROM expense_splits es\n            JOIN profiles sp ON sp.id = es.user_id\n            WHERE es.expense_id = e.id\n          )\n        )\n        ORDER BY e.date DESC, e.created_at DESC\n      ), '[]'::json)\n      FROM expenses e\n      JOIN profiles p ON p.id = e.paid_by\n      WHERE e.household_id = p_household_id\n      LIMIT 50\n    ),\n    'recent_settlements', (\n      SELECT COALESCE(json_agg(\n        json_build_object(\n          'id', s.id,\n          'household_id', s.household_id,\n          'payer_id', s.payer_id,\n          'payee_id', s.payee_id,\n          'amount', s.amount,\n          'description', s.description,\n          'created_at', s.created_at,\n          'payer_profile', row_to_json(payer.*),\n          'payee_profile', row_to_json(payee.*)\n        )\n        ORDER BY s.created_at DESC\n      ), '[]'::json)\n      FROM settlements s\n      JOIN profiles payer ON payer.id = s.payer_id\n      JOIN profiles payee ON payee.id = s.payee_id\n      WHERE s.household_id = p_household_id\n      LIMIT 20\n    )\n    -- The 'tasks' and 'recent_messages' sections have been removed.\n  ) INTO result;\n  \n  RETURN result;\nEND;$function$\n"
    },
    {
      "function_name": "handle_new_user",
      "comment": "Definition for the handle_new_user function.",
      "definition": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$BEGIN\n  INSERT INTO public.profiles (id, name)\n  VALUES (\n    new.id,\n    COALESCE(\n      new.raw_user_meta_data->>'name',\n      split_part(new.email, '@', 1),\n      new.phone\n    )\n  );\n  RETURN new;\nEND;$function$\n"
    },
    {
      "function_name": "get_user_households_with_counts",
      "comment": "Definition for the get_user_households_with_counts function.",
      "definition": "CREATE OR REPLACE FUNCTION public.get_user_households_with_counts(p_user_id uuid)\n RETURNS TABLE(id uuid, name text, created_by uuid, created_at timestamp with time zone, updated_at timestamp with time zone, member_count bigint)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT\n        h.id,\n        h.name,\n        h.created_by,\n        h.created_at,\n        h.updated_at,\n        COUNT(hm_counter.id) as member_count\n    FROM\n        households h\n    -- Join to find which households the user is a member of\n    JOIN\n        household_members hm_user ON h.id = hm_user.household_id\n    -- Left Join to count all members in those households\n    LEFT JOIN\n        household_members hm_counter ON h.id = hm_counter.household_id\n    WHERE\n        hm_user.user_id = p_user_id\n    GROUP BY\n        h.id;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_expense_context",
      "comment": "Definition for the get_expense_context function.",
      "definition": "CREATE OR REPLACE FUNCTION public.get_expense_context(p_household_id uuid, p_user_id uuid, p_limit integer DEFAULT 10)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_result JSONB;\nBEGIN\n    SELECT jsonb_build_object(\n        'recent_expenses', (\n            SELECT COALESCE(\n                jsonb_agg(\n                    jsonb_build_object(\n                        'id', expense_data.id,\n                        'description', expense_data.description,\n                        'amount', expense_data.amount,\n                        'date', expense_data.date,\n                        'paid_by', expense_data.paid_by_name,\n                        'splits', expense_data.splits\n                    ) ORDER BY expense_data.date DESC\n                ),\n                '[]'::jsonb\n            )\n            FROM (\n                SELECT \n                    e.id,\n                    e.description,\n                    e.amount,\n                    e.date,\n                    p.name as paid_by_name,\n                    COALESCE(\n                        jsonb_agg(\n                            jsonb_build_object(\n                                'member', sp.name,\n                                'amount', es.amount\n                            )\n                        ) FILTER (WHERE es.id IS NOT NULL),\n                        '[]'::jsonb\n                    ) as splits\n                FROM expenses e\n                JOIN profiles p ON e.paid_by = p.id\n                LEFT JOIN expense_splits es ON e.id = es.expense_id\n                LEFT JOIN profiles sp ON es.user_id = sp.id\n                WHERE e.household_id = p_household_id\n                -- Removed: AND e.is_active = true (column doesn't exist)\n                GROUP BY e.id, e.description, e.amount, e.date, p.name\n                ORDER BY e.date DESC\n                LIMIT p_limit\n            ) expense_data\n        ),\n        'balances', (\n            SELECT COALESCE(\n                jsonb_agg(\n                    jsonb_build_object(\n                        'from', b.debtor_name,\n                        'to', b.creditor_name,\n                        'amount', b.amount,\n                        'direction', 'owes'\n                    )\n                ),\n                '[]'::jsonb\n            )\n            FROM get_household_balances(p_household_id) b\n        ),\n        'user_balance', (\n            SELECT COALESCE(balance, 0)\n            FROM ledger_balances\n            WHERE household_id = p_household_id\n              AND user_id = p_user_id\n        )\n    ) INTO v_result;\n    \n    RETURN v_result;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_rag_context",
      "comment": "Definition for the get_rag_context function.",
      "definition": "CREATE OR REPLACE FUNCTION public.get_rag_context(p_household_id uuid, p_user_id uuid, p_intent text DEFAULT 'all'::text, p_options jsonb DEFAULT '{}'::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\n  DECLARE\n      v_context jsonb := '{}'::jsonb;\n      v_expense_context jsonb;\n      v_chore_context jsonb;\n      v_info_context jsonb;\n      v_system_context jsonb;\n  BEGIN\n      -- Always include system context\n      v_system_context := jsonb_build_object(\n          'current_datetime', now(),\n          'current_date', CURRENT_DATE,\n          'day_of_week', to_char(CURRENT_DATE, 'Day'),\n          'time', to_char(now(), 'HH24:MI')\n      );\n      v_context := v_context || jsonb_build_object('system', v_system_context);\n\n      -- Get context based on intent\n      CASE p_intent\n          WHEN 'expense' THEN\n              v_expense_context := get_expense_context(p_household_id, p_user_id,\n                  COALESCE((p_options->>'expense_limit')::integer, 10));\n              v_context := v_context || jsonb_build_object('expense', v_expense_context);\n\n          WHEN 'chore' THEN\n              v_chore_context := get_chore_context(p_household_id, p_user_id,\n                  COALESCE((p_options->>'days_ahead')::integer, 7));\n              v_context := v_context || jsonb_build_object('chore', v_chore_context);\n\n          WHEN 'info' THEN\n              v_info_context := get_household_info_context(p_household_id, p_user_id);\n              v_context := v_context || jsonb_build_object('info', v_info_context);\n\n          WHEN 'all' THEN\n              -- Get all contexts for general queries\n              v_expense_context := get_expense_context(p_household_id, p_user_id, 5);\n              v_chore_context := get_chore_context(p_household_id, p_user_id, 7);\n              v_info_context := get_household_info_context(p_household_id, p_user_id);\n\n              v_context := v_context || jsonb_build_object(\n                  'expense', v_expense_context,\n                  'chore', v_chore_context,\n                  'info', v_info_context\n              );\n\n          ELSE\n              -- Default to all if unknown intent\n              v_context := get_rag_context(p_household_id, p_user_id, 'all', p_options);\n      END CASE;\n\n      -- Add metadata\n      v_context := v_context || jsonb_build_object(\n          'metadata', jsonb_build_object(\n              'household_id', p_household_id,\n              'user_id', p_user_id,\n              'intent', p_intent,\n              'generated_at', now()\n          )\n      );\n\n      RETURN v_context;\n  END;\n  $function$\n"
    },
    {
      "function_name": "get_household_balances",
      "comment": "Definition for the get_household_balances function.",
      "definition": "CREATE OR REPLACE FUNCTION public.get_household_balances(household_id_param uuid)\n RETURNS TABLE(debtor_id uuid, debtor_name text, creditor_id uuid, creditor_name text, amount numeric)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\n  BEGIN\n      -- Return pairwise balances based on ledger_balances\n      RETURN QUERY\n      WITH household_balances AS (\n          SELECT\n              lb.user_id,\n              p.name as user_name,\n              lb.balance\n          FROM public.ledger_balances lb\n          JOIN public.profiles p ON lb.user_id = p.id\n          WHERE lb.household_id = household_id_param\n          AND lb.balance != 0\n      ),\n      pairwise_balances AS (\n          SELECT\n              CASE WHEN hb1.balance < 0 THEN hb1.user_id ELSE hb2.user_id END as debtor_id,\n              CASE WHEN hb1.balance < 0 THEN hb1.user_name ELSE hb2.user_name END as debtor_name,\n              CASE WHEN hb1.balance > 0 THEN hb1.user_id ELSE hb2.user_id END as creditor_id,\n              CASE WHEN hb1.balance > 0 THEN hb1.user_name ELSE hb2.user_name END as creditor_name,\n              LEAST(abs(hb1.balance), abs(hb2.balance)) as amount\n          FROM household_balances hb1\n          CROSS JOIN household_balances hb2\n          WHERE hb1.user_id < hb2.user_id  -- Avoid duplicates\n          AND hb1.balance * hb2.balance < 0  -- One positive, one negative\n      )\n      SELECT\n          pb.debtor_id,\n          pb.debtor_name,\n          pb.creditor_id,\n          pb.creditor_name,\n          pb.amount\n      FROM pairwise_balances pb\n      WHERE pb.amount > 0\n      ORDER BY pb.amount DESC;\n  END;\n  $function$\n"
    },
    {
      "function_name": "get_chore_context",
      "comment": "Definition for the get_chore_context function.",
      "definition": "CREATE OR REPLACE FUNCTION public.get_chore_context(p_household_id uuid, p_user_id uuid, p_days_ahead integer DEFAULT 7)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\n  DECLARE\n      v_context jsonb;\n      v_assignments jsonb;\n      v_user_chores jsonb;\n      v_chore_settings jsonb;\n  BEGIN\n      -- Verify user is member of household\n      IF NOT EXISTS (\n          SELECT 1 FROM household_members\n          WHERE household_id = p_household_id\n          AND user_id = p_user_id\n      ) THEN\n          RAISE EXCEPTION 'User is not a member of this household';\n      END IF;\n\n      -- Get week's chore assignments\n      SELECT jsonb_agg(\n          jsonb_build_object(\n              'date', ca.due_date,\n              'chore', hc.name,\n              'assigned_to', p.name,\n              'status', ca.status,\n              'is_user', (ca.assigned_user_id = p_user_id::text)\n          ) ORDER BY ca.due_date\n      ) INTO v_assignments\n      FROM chore_assignments ca\n      JOIN household_chores hc ON ca.household_chore_id = hc.id\n      JOIN profiles p ON ca.assigned_user_id = p.id::text\n      WHERE ca.household_id = p_household_id\n      AND ca.due_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '1 day' * p_days_ahead;\n\n      -- Get user's specific chores\n      SELECT jsonb_agg(\n          jsonb_build_object(\n              'date', ca.due_date,\n              'chore', hc.name,\n              'status', ca.status\n          ) ORDER BY ca.due_date\n      ) INTO v_user_chores\n      FROM chore_assignments ca\n      JOIN household_chores hc ON ca.household_chore_id = hc.id\n      WHERE ca.household_id = p_household_id\n      AND ca.assigned_user_id = p_user_id::text\n      AND ca.due_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '1 day' * p_days_ahead;\n\n      -- For now, return empty settings since the columns don't exist\n      -- In the future, these could be added to the households table or a separate settings table\n      v_chore_settings := jsonb_build_object(\n          'reset_day', null,\n          'reset_time', null,\n          'auto_assign', null\n      );\n\n      -- Build context\n      v_context := jsonb_build_object(\n          'all_assignments', COALESCE(v_assignments, '[]'::jsonb),\n          'user_chores', COALESCE(v_user_chores, '[]'::jsonb),\n          'settings', v_chore_settings,\n          'current_date', CURRENT_DATE,\n          'timestamp', now()\n      );\n\n      RETURN v_context;\n  END;\n$function$\n"
    },
    {
      "function_name": "get_household_info_context",
      "comment": "Definition for the get_household_info_context function.",
      "definition": "CREATE OR REPLACE FUNCTION public.get_household_info_context(p_household_id uuid, p_user_id uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\n  DECLARE\n      v_context jsonb;\n      v_household jsonb;\n      v_members jsonb;\n      v_rules text;\n  BEGIN\n      -- Verify user is member of household\n      IF NOT EXISTS (\n          SELECT 1 FROM household_members\n          WHERE household_id = p_household_id\n          AND user_id = p_user_id\n      ) THEN\n          RAISE EXCEPTION 'User is not a member of this household';\n      END IF;\n\n      -- Get household info (removed chore_reset_day which doesn't exist)\n      SELECT jsonb_build_object(\n          'name', h.name,\n          'join_code', h.join_code,\n          'created_at', h.created_at,\n          'rules', h.rules\n      ) INTO v_household\n      FROM households h\n      WHERE h.id = p_household_id;\n\n      -- Get members\n      SELECT jsonb_agg(\n          jsonb_build_object(\n              'name', p.name,\n              'role', hm.role,\n              'joined_at', hm.joined_at,\n              'is_current_user', (p.id = p_user_id)\n          ) ORDER BY hm.joined_at\n      ) INTO v_members\n      FROM household_members hm\n      JOIN profiles p ON hm.user_id = p.id\n      WHERE hm.household_id = p_household_id;\n\n      -- Build context\n      v_context := jsonb_build_object(\n          'household', v_household,\n          'members', COALESCE(v_members, '[]'::jsonb),\n          'member_count', (SELECT COUNT(*) FROM household_members WHERE household_id = p_household_id),\n          'timestamp', now()\n      );\n\n      RETURN v_context;\n  END;\n  $function$\n"
    },
    {
      "function_name": "snooze_chore_assignment",
      "comment": "Definition for the snooze_chore_assignment function.",
      "definition": "CREATE OR REPLACE FUNCTION public.snooze_chore_assignment(p_assignment_id uuid, p_new_due_date date, p_reason text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\n  DECLARE\n      v_current_assignment RECORD;\n      v_user_id uuid;\n      v_admin_count integer; -- New variable to hold the count\n  BEGIN\n      -- Get current user\n      v_user_id := auth.uid();\n\n      -- Get current assignment details\n      SELECT ca.*, hm.user_id as member_user_id\n      INTO v_current_assignment\n      FROM chore_assignments ca\n      JOIN household_members hm ON hm.household_id = ca.household_id\n      WHERE ca.id = p_assignment_id\n      AND hm.user_id = v_user_id;\n\n      -- Check if user has permission (either assigned to them or is admin)\n      IF v_current_assignment.id IS NULL THEN\n          RAISE EXCEPTION 'Assignment not found or no permission';\n      END IF;\n\n      IF v_current_assignment.assigned_user_id != v_user_id::text THEN\n          -- Check if user is admin\n          SELECT COUNT(*) INTO v_admin_count -- Use separate variable\n          FROM household_members\n          WHERE household_id = v_current_assignment.household_id\n          AND user_id = v_user_id\n          AND role = 'admin';\n\n          IF v_admin_count = 0 THEN\n              RAISE EXCEPTION 'Only the assigned user or admin can snooze this chore';\n          END IF;\n      END IF;\n\n      -- Validate new date is in the future\n      IF p_new_due_date <= CURRENT_DATE THEN\n          RAISE EXCEPTION 'New due date must be in the future';\n      END IF;\n\n      -- Update the assignment\n      UPDATE chore_assignments\n      SET\n          due_date = p_new_due_date,\n          notes = COALESCE(notes || E'\\n', '') ||\n                  format('Snoozed from %s to %s%s',\n                         v_current_assignment.due_date::text,\n                         p_new_due_date::text,\n                         CASE WHEN p_reason IS NOT NULL THEN ' - ' || p_reason ELSE '' END),\n          updated_at = NOW()\n      WHERE id = p_assignment_id;\n\n      -- Create notification\n      PERFORM create_household_notification(\n          v_current_assignment.household_id,\n          'chore_snoozed',\n          'Chore Rescheduled',\n          format('\"%s\" has been postponed to %s',\n                 (SELECT name FROM household_chores WHERE id = v_current_assignment.household_chore_id),\n                 p_new_due_date::text),\n          jsonb_build_object(\n              'assignment_id', p_assignment_id,\n              'old_date', v_current_assignment.due_date,\n              'new_date', p_new_due_date,\n              'reason', p_reason\n          )\n      );\n\n      RETURN jsonb_build_object(\n          'success', true,\n          'assignment_id', p_assignment_id,\n          'new_due_date', p_new_due_date,\n          'message', 'Chore successfully snoozed'\n      );\n  END;\n  $function$\n"
    }
  ],
  "triggers": [
    {
      "trigger_name": "ensure_invitation_email_lowercase",
      "comment": "Definition for the ensure_invitation_email_lowercase trigger.",
      "table": "invitations",
      "event": "INSERT",
      "definition": "EXECUTE FUNCTION ensure_lowercase_email()"
    },
    {
      "trigger_name": "ensure_invitation_email_lowercase",
      "comment": "Definition for the ensure_invitation_email_lowercase trigger.",
      "table": "invitations",
      "event": "UPDATE",
      "definition": "EXECUTE FUNCTION ensure_lowercase_email()"
    },
    {
      "trigger_name": "set_updated_at",
      "comment": "Definition for the set_updated_at trigger.",
      "table": "messages",
      "event": "UPDATE",
      "definition": "EXECUTE FUNCTION handle_updated_at()"
    },
    {
      "trigger_name": "trigger_notify_message_sent",
      "comment": "Definition for the trigger_notify_message_sent trigger.",
      "table": "messages",
      "event": "INSERT",
      "definition": "EXECUTE FUNCTION notify_message_sent()"
    },
    {
      "trigger_name": "set_invitations_updated_at",
      "comment": "Definition for the set_invitations_updated_at trigger.",
      "table": "invitations",
      "event": "UPDATE",
      "definition": "EXECUTE FUNCTION handle_updated_at()"
    },
    {
      "trigger_name": "set_updated_at",
      "comment": "Definition for the set_updated_at trigger.",
      "table": "profiles",
      "event": "UPDATE",
      "definition": "EXECUTE FUNCTION handle_updated_at()"
    },
    {
      "trigger_name": "set_updated_at",
      "comment": "Definition for the set_updated_at trigger.",
      "table": "households",
      "event": "UPDATE",
      "definition": "EXECUTE FUNCTION handle_updated_at()"
    },
    {
      "trigger_name": "set_updated_at",
      "comment": "Definition for the set_updated_at trigger.",
      "table": "expenses",
      "event": "UPDATE",
      "definition": "EXECUTE FUNCTION handle_updated_at()"
    },
    {
      "trigger_name": "set_updated_at",
      "comment": "Definition for the set_updated_at trigger.",
      "table": "tasks",
      "event": "UPDATE",
      "definition": "EXECUTE FUNCTION handle_updated_at()"
    },
    {
      "trigger_name": "trigger_notify_expense_created",
      "comment": "Definition for the trigger_notify_expense_created trigger.",
      "table": "expenses",
      "event": "INSERT",
      "definition": "EXECUTE FUNCTION notify_expense_created()"
    },
    {
      "trigger_name": "trigger_notify_settlement_created",
      "comment": "Definition for the trigger_notify_settlement_created trigger.",
      "table": "settlements",
      "event": "INSERT",
      "definition": "EXECUTE FUNCTION notify_settlement_created()"
    },
    {
      "trigger_name": "trigger_notify_recurring_expense",
      "comment": "Definition for the trigger_notify_recurring_expense trigger.",
      "table": "expenses",
      "event": "INSERT",
      "definition": "EXECUTE FUNCTION notify_recurring_expense_processed()"
    },
    {
      "trigger_name": "set_updated_at",
      "comment": "Definition for the set_updated_at trigger.",
      "table": "invitations",
      "event": "UPDATE",
      "definition": "EXECUTE FUNCTION handle_invitations_updated_at()"
    },
    {
      "trigger_name": "on_new_message",
      "comment": "Definition for the on_new_message trigger.",
      "table": "messages",
      "event": "INSERT",
      "definition": "EXECUTE FUNCTION notify_new_message_with_profile()"
    },
    {
      "trigger_name": "update_ledger_on_settlement",
      "comment": "Definition for the update_ledger_on_settlement trigger.",
      "table": "settlements",
      "event": "INSERT",
      "definition": "EXECUTE FUNCTION trigger_update_ledger_on_settlement()"
    }
  ]
}